// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现游戏引擎，统筹游戏流程和规则执行

import '../models/board_state.dart';
import '../models/position.dart';
import '../models/piece_type.dart';
import '../models/move.dart';
import '../models/game_result.dart';
import 'move_validator.dart';
import 'capture_detector.dart';

/// 移动结果
class MoveResult {
  /// 移动是否成功
  final bool success;
  
  /// 移动记录（如果成功）
  final Move? move;
  
  /// 被吃棋子位置（如果有）
  final Position? captured;
  
  /// 游戏是否结束
  final bool gameOver;
  
  /// 游戏结果（如果结束）
  final GameResult? gameResult;
  
  /// 错误信息（如果失败）
  final String? error;
  
  /// 新的棋盘状态
  final BoardState? newBoard;

  const MoveResult({
    required this.success,
    this.move,
    this.captured,
    this.gameOver = false,
    this.gameResult,
    this.error,
    this.newBoard,
  });

  /// 创建成功结果
  factory MoveResult.success({
    required Move move,
    Position? captured,
    required bool gameOver,
    GameResult? gameResult,
    required BoardState newBoard,
  }) {
    return MoveResult(
      success: true,
      move: move,
      captured: captured,
      gameOver: gameOver,
      gameResult: gameResult,
      newBoard: newBoard,
    );
  }

  /// 创建失败结果
  factory MoveResult.failure(String error) {
    return MoveResult(
      success: false,
      error: error,
    );
  }
}

/// 游戏引擎
/// 
/// 负责游戏核心流程：
/// - 移动执行
/// - 吃子检测
/// - 胜负判定
/// - 游戏状态管理
class GameEngine {
  final MoveValidator _validator;
  final CaptureDetector _captureDetector;
  
  /// 移动历史记录
  final List<Move> _moveHistory = [];
  
  /// 游戏开始时间
  DateTime? _startTime;

  GameEngine()
      : _validator = MoveValidator(),
        _captureDetector = CaptureDetector();

  /// 开始新游戏
  void startNewGame() {
    _moveHistory.clear();
    _startTime = DateTime.now();
  }

  /// 执行移动
  /// 
  /// 验证移动合法性，执行移动，检测吃子，更新状态
  MoveResult executeMove(
    BoardState board,
    Position from,
    Position to,
  ) {
    // 1. 验证移动合法性
    if (!_validator.isValidMove(board, from, to)) {
      return MoveResult.failure('移动不合法');
    }

    // 2. 执行移动
    var newBoard = board.movePiece(from, to);
    final player = board.currentPlayer;

    // 3. 检测吃子
    final capturedPos = _captureDetector.detectCapture(
      newBoard,
      to,
      player,
    );

    // 4. 如果有吃子，移除被吃棋子
    if (capturedPos != null) {
      newBoard = newBoard.removePiece(capturedPos);
    }

    // 5. 创建移动记录
    final move = Move.now(
      from: from,
      to: to,
      player: player,
      capturedPiece: capturedPos,
    );
    _moveHistory.add(move);

    // 6. 检查游戏是否结束
    final gameResult = checkGameOver(newBoard);
    final gameOver = gameResult != null;

    // 7. 如果游戏未结束，切换玩家
    if (!gameOver) {
      newBoard = newBoard.switchPlayer();
    }

    return MoveResult.success(
      move: move,
      captured: capturedPos,
      gameOver: gameOver,
      gameResult: gameResult,
      newBoard: newBoard,
    );
  }

  /// 检查游戏是否结束
  /// 
  /// 判定规则：
  /// - 某方棋子数 <= 1：对方获胜
  /// - 某方无合法移动：对方获胜（可选规则）
  GameResult? checkGameOver(BoardState board) {
    final blackCount = board.getPieceCount(PieceType.black);
    final whiteCount = board.getPieceCount(PieceType.white);

    final duration = _startTime != null
        ? DateTime.now().difference(_startTime!)
        : Duration.zero;

    // 黑方棋子不足
    if (blackCount <= 1) {
      return GameResult.whiteWin(
        reason: '黑方棋子数量不足',
        moveCount: _moveHistory.length,
        duration: duration,
      );
    }

    // 白方棋子不足
    if (whiteCount <= 1) {
      return GameResult.blackWin(
        reason: '白方棋子数量不足',
        moveCount: _moveHistory.length,
        duration: duration,
      );
    }

    // 游戏继续
    return null;
  }

  /// 获取所有可能的移动
  /// 
  /// 返回当前玩家所有合法移动
  Map<Position, List<Position>> getPossibleMoves(
    BoardState board,
    PieceType player,
  ) {
    return _validator.getAllPossibleMoves(board, player);
  }

  /// 获取移动历史
  List<Move> get moveHistory => List.unmodifiable(_moveHistory);

  /// 获取游戏时长
  Duration get gameDuration {
    if (_startTime == null) return Duration.zero;
    return DateTime.now().difference(_startTime!);
  }

  /// 模拟移动（不改变实际状态，用于AI）
  /// 
  /// 返回移动后的棋盘状态
  BoardState? simulateMove(
    BoardState board,
    Position from,
    Position to,
  ) {
    if (!_validator.isValidMove(board, from, to)) {
      return null;
    }

    var newBoard = board.movePiece(from, to);
    final player = board.currentPlayer;

    // 检测并执行吃子
    final capturedPos = _captureDetector.detectCapture(
      newBoard,
      to,
      player,
    );

    if (capturedPos != null) {
      newBoard = newBoard.removePiece(capturedPos);
    }

    // 切换玩家
    newBoard = newBoard.switchPlayer();

    return newBoard;
  }

  /// 评估棋盘局面（简单版本，用于AI）
  /// 
  /// 返回分数，正数表示对player有利
  int evaluateBoard(BoardState board, PieceType player) {
    final opponent = player.getOpponent();
    
    // 棋子数量差
    final myPieces = board.getPieceCount(player);
    final opponentPieces = board.getPieceCount(opponent);
    
    return (myPieces - opponentPieces) * 100;
  }

  /// 撤销上一步移动（用于悔棋功能）
  /// 
  /// 返回撤销后的棋盘状态，如果无法撤销则返回null
  BoardState? undoLastMove(BoardState currentBoard) {
    if (_moveHistory.isEmpty) {
      return null;
    }

    // 从初始状态重新执行所有移动（除了最后一步）
    final movesToReplay = _moveHistory.take(_moveHistory.length - 1).toList();
    _moveHistory.removeLast();

    var board = BoardState.initial();
    for (final move in movesToReplay) {
      final result = executeMove(board, move.from, move.to);
      if (!result.success || result.newBoard == null) {
        return null;
      }
      board = result.newBoard!;
    }

    return board;
  }

  /// 获取吃子机会
  /// 
  /// 返回所有可以吃子的移动
  Map<Position, Map<Position, Position>> getCaptureOpportunities(
    BoardState board,
    PieceType player,
  ) {
    return _captureDetector.getAllCaptureOpportunities(board, player);
  }

  /// 重置游戏引擎
  void reset() {
    _moveHistory.clear();
    _startTime = null;
  }
}
