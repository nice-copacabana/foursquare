// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现吃子检测器，检测移动后是否形成吃子情况

import '../models/board_state.dart';
import '../models/position.dart';
import '../models/piece_type.dart';

/// 吃子检测器
/// 
/// 负责检测移动后是否可以吃子
/// 
/// 吃子规则：
/// 移动后，如果在某个方向（上/下/左/右）形成"己-己-敌"的连续三子，则吃掉敌方棋子
/// 移动的棋子必须参与这个三子连线
class CaptureDetector {
  /// 四个方向的偏移量：上、下、左、右
  static const List<Position> _directions = [
    Position(0, -1), // 上
    Position(0, 1),  // 下
    Position(-1, 0), // 左
    Position(1, 0),  // 右
  ];

  /// 检测移动后是否可以吃子
  /// 
  /// 参数：
  /// - board: 当前棋盘状态
  /// - movedPiece: 刚移动到的棋子位置
  /// - player: 移动方
  /// 
  /// 返回：被吃棋子的位置，如果没有吃子则返回null
  /// 
  /// 吃子规则：
  /// 1. 必须形成"己-己-敌"的连续三子
  /// 2. 移动的棋子必须是前两个"己"之一  
  /// 3. 不能形成"敌-己-己"模式(敌方在己方之前)
  Position? detectCapture(
    BoardState board,
    Position movedPiece,
    PieceType player,
  ) {
    if (!movedPiece.isValid() || player == PieceType.empty) {
      return null;
    }

    final enemy = player.getOpponent();

    // 检查四个方向
    for (final direction in _directions) {
      // 情况1: 移动的棋子在第一个位置 (移动-己-敌)
      final pos1 = movedPiece;
      final pos2 = Position(pos1.x + direction.x, pos1.y + direction.y);
      final pos3 = Position(pos2.x + direction.x, pos2.y + direction.y);

      if (_isValidCapture(board, pos1, pos2, pos3, player, enemy)) {
        // 检查是否形成了"敌-己-己"模式(不允许)
        final posBeforeEnemy = Position(pos3.x + direction.x, pos3.y + direction.y);
        if (posBeforeEnemy.isValid() && board.getPiece(posBeforeEnemy) == enemy) {
          // 形成了"己-己-敌-敌"模式,不应吃子  
          continue;
        }
        
        // 检查反方向是否有敌方棋子
        final posBack = Position(pos1.x - direction.x, pos1.y - direction.y);
        if (posBack.isValid() && board.getPiece(posBack) == enemy) {
          // 形成了"敌-己-己-敌"模式,不应吃子
          continue;
        }
        
        return pos3;
      }

      // 情况2: 移动的棋子在第二个位置 (己-移动-敌)
      final pos0 = Position(pos1.x - direction.x, pos1.y - direction.y);

      if (_isValidCapture(board, pos0, pos1, pos2, player, enemy)) {
        return pos2;
      }
    }

    return null;
  }

  /// 验证是否形成有效的吃子情况
  /// 
  /// 检查三个位置是否形成"己-己-敌"的模式
  bool _isValidCapture(
    BoardState board,
    Position pos1,
    Position pos2,
    Position pos3,
    PieceType player,
    PieceType enemy,
  ) {
    // 检查位置有效性
    if (!pos1.isValid() || !pos2.isValid() || !pos3.isValid()) {
      return false;
    }

    // 检查是否形成"己-己-敌"
    return board.getPiece(pos1) == player &&
        board.getPiece(pos2) == player &&
        board.getPiece(pos3) == enemy;
  }

  /// 检测所有可能的吃子机会
  /// 
  /// 返回所有可以吃子的移动
  /// Map的key是起始位置，value是一个Map，其中key是目标位置，value是被吃棋子位置
  Map<Position, Map<Position, Position>> getAllCaptureOpportunities(
    BoardState board,
    PieceType player,
  ) {
    final result = <Position, Map<Position, Position>>{};
    final pieces = board.getAllPieces(player);

    for (final piece in pieces) {
      // 获取该棋子的所有相邻空位
      final adjacentPositions = piece.getAdjacentPositions();
      final emptyPositions = adjacentPositions
          .where((pos) => board.isEmpty(pos))
          .toList();

      for (final target in emptyPositions) {
        // 模拟移动
        final newBoard = board.movePiece(piece, target);
        
        // 检测是否能吃子
        final captured = detectCapture(newBoard, target, player);
        
        if (captured != null) {
          result[piece] ??= {};
          result[piece]![target] = captured;
        }
      }
    }

    return result;
  }

  /// 检查指定位置的棋子是否有被吃的风险
  /// 
  /// 返回可能吃掉该棋子的对手移动
  List<CaptureRisk> getCaptureRisks(
    BoardState board,
    Position piece,
  ) {
    final pieceType = board.getPiece(piece);
    if (pieceType == PieceType.empty) {
      return [];
    }

    final enemy = pieceType.getOpponent();
    final risks = <CaptureRisk>[];

    // 检查四个方向
    for (final direction in _directions) {
      // 检查"敌-己-己"的情况（敌方移动到piece前面）
      final pos0 = Position(piece.x - direction.x, piece.y - direction.y);
      final pos1 = piece;
      final pos2 = Position(piece.x + direction.x, piece.y + direction.y);

      if (pos0.isValid() && pos2.isValid()) {
        if (board.isEmpty(pos0) &&
            board.getPiece(pos1) == pieceType &&
            board.getPiece(pos2) == pieceType) {
          // 如果敌方棋子能移动到pos0，就能吃掉pos2
          risks.add(CaptureRisk(
            threatenedPiece: pos2,
            enemyTarget: pos0,
          ),);
        }
      }

      // 检查"己-己-敌"的情况（piece可能被吃）
      final back1 = Position(piece.x - direction.x, piece.y - direction.y);
      final back2 = Position(piece.x - 2 * direction.x, piece.y - 2 * direction.y);

      if (back1.isValid() && back2.isValid()) {
        if (board.getPiece(back2) == enemy &&
            board.getPiece(back1) == enemy) {
          // 当前piece有被吃的风险
          risks.add(CaptureRisk(
            threatenedPiece: piece,
            enemyTarget: null, // 已经形成威胁
          ),);
        }
      }
    }

    return risks;
  }
}

/// 吃子风险信息
class CaptureRisk {
  /// 受威胁的棋子位置
  final Position threatenedPiece;
  
  /// 敌方需要移动到的目标位置（如果为null表示已形成威胁）
  final Position? enemyTarget;

  const CaptureRisk({
    required this.threatenedPiece,
    this.enemyTarget,
  });

  @override
  String toString() {
    return 'CaptureRisk(threatened: $threatenedPiece, enemyTarget: $enemyTarget)';
  }
}
