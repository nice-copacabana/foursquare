// Generated by Qoder AI (Model: gemini-3-pro) - 2025-11-25
// Task: 音频总控制器 - 协调音效/音乐/语音三个服务,统一管理音频事件

import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../models/audio_settings.dart';
import '../services/audio_service.dart';
import '../services/music_service.dart';
import '../services/voice_synthesis_service.dart';
import '../services/logger_service.dart';

/// 游戏事件枚举
enum GameEvent {
  /// 选中棋子
  pieceSelected,
  
  /// 移动棋子
  pieceMoved,
  
  /// 吃子
  pieceCaptured,
  
  /// 游戏胜利
  gameWon,
  
  /// 游戏失败
  gameLost,
  
  /// 轮次切换
  turnChanged,
  
  /// AI思考中
  aiThinking,
  
  /// 非法操作
  invalidOperation,
  
  /// 按钮点击
  buttonClicked,
}

/// 游戏场景枚举
enum GameScene {
  /// 主菜单
  mainMenu,
  
  /// 普通对弈
  gameplay,
  
  /// 冥想模式
  meditationMode,
  
  /// AI对弈
  aiGame,
  
  /// 回放模式
  replayMode,
  
  /// 设置页面
  settings,
}

/// 音频总控制器
/// 
/// 职责:
/// - 协调音效、音乐、语音三个服务
/// - 管理音频冲突和优先级
/// - 统一音频配置和持久化
/// - 响应游戏事件触发对应音频
class AudioCoordinator {
  static final AudioCoordinator _instance = AudioCoordinator._internal();
  factory AudioCoordinator() => _instance;
  AudioCoordinator._internal();

  final AudioService _audioService = AudioService();
  final MusicService _musicService = MusicService();
  final VoiceSynthesisService _voiceService = VoiceSynthesisService();
  SharedPreferences? _prefs;

  AudioSettings _settings = AudioSettings.defaultSettings;
  GameScene _currentScene = GameScene.mainMenu;
  bool _isVoicePlaying = false;
  bool _voiceProcessing = false;
  double _originalMusicVolume = 0.4;
  final List<_VoiceAnnouncement> _voiceQueue = [];
  DateTime? _lastAiThinkingAt;

  static const String _keyAudioSettings = 'audio_settings';

  /// 获取当前设置
  AudioSettings get settings => _settings;

  /// 初始化音频协调器
  Future<void> initialize() async {
    try {
      // 初始化SharedPreferences
      _prefs = await SharedPreferences.getInstance();
      
      // 加载设置
      await _loadSettings();

      // 初始化各服务
      await _audioService.initialize();
      await _musicService.initialize();
      await _voiceService.initialize();

      // 应用设置
      await _applySettings();

      logger.info('音频协调器初始化成功', 'AudioCoordinator');
    } catch (e) {
      logger.error('音频协调器初始化失败', 'AudioCoordinator', e);
    }
  }

  /// 加载音频设置
  Future<void> _loadSettings() async {
    try {
      final jsonStr = _prefs?.getString(_keyAudioSettings);
      if (jsonStr != null) {
        final map = jsonDecode(jsonStr) as Map<String, dynamic>;
        _settings = AudioSettings.fromMap(map);
        logger.info('已加载音频设置', 'AudioCoordinator');
      }
    } catch (e) {
      logger.warning('加载音频设置失败,使用默认值', 'AudioCoordinator');
      _settings = AudioSettings.defaultSettings;
    }
  }

  /// 保存音频设置
  Future<void> _saveSettings() async {
    try {
      final jsonStr = jsonEncode(_settings.toMap());
      await _prefs?.setString(_keyAudioSettings, jsonStr);
      logger.info('已保存音频设置', 'AudioCoordinator');
    } catch (e) {
      logger.error('保存音频设置失败', 'AudioCoordinator', e);
    }
  }

  /// 应用设置到各服务
  Future<void> _applySettings() async {
    // 音效设置
    _audioService.setEnabled(_settings.soundEnabled);
    _audioService.setVolume(_settings.soundVolume);

    // 音乐设置
    await _musicService.setEnabled(_settings.musicEnabled);
    await _musicService.setVolume(_settings.musicVolume);
    _originalMusicVolume = _settings.musicVolume;

    // 语音设置
    await _voiceService.setVolume(_settings.voiceVolume);
    await _voiceService.setSpeechRate(_settings.voiceSpeechRate);
    await _voiceService.setPitch(_settings.voicePitch);
  }

  /// 更新音频设置
  Future<void> updateSettings(AudioSettings newSettings) async {
    _settings = newSettings;
    await _applySettings();
    await _saveSettings();
  }

  /// 响应游戏事件
  void onGameEvent(GameEvent event, {Map<String, dynamic>? data}) {
    if (!_settings.soundEnabled && !_settings.voiceEnabled) return;

    switch (event) {
      case GameEvent.pieceSelected:
        _audioService.playSound(SoundType.select);
        break;

      case GameEvent.pieceMoved:
        _audioService.playSound(SoundType.move);
        break;

      case GameEvent.pieceCaptured:
        _audioService.playSound(SoundType.capture);
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _enqueueAnnouncement('${player}??????', priority: 1);
        }
        break;

      case GameEvent.gameWon:
        _audioService.playSound(SoundType.win);
        _musicService.playMusic(MusicTheme.victory);
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _enqueueAnnouncement('${player}??', priority: 3, interrupt: true);
        }
        break;

      case GameEvent.gameLost:
        _audioService.playSound(SoundType.lose);
        if (_settings.voiceEnabled) {
          final player = data?['player'] as String?;
          _enqueueAnnouncement(player != null && player.isNotEmpty ? '${player}??' : '????', priority: 3, interrupt: true);
        }
        break;

      case GameEvent.turnChanged:
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _enqueueAnnouncement('??${player}', priority: 1);
        }
        break;

      case GameEvent.aiThinking:
        if (_settings.voiceEnabled && _shouldAnnounceAiThinking()) {
          _enqueueAnnouncement('AI????', priority: 0);
        }
        break;

      case GameEvent.invalidOperation:
        if (_settings.voiceEnabled) {
          _enqueueAnnouncement('????', priority: 1);
        }
        break;

      case GameEvent.buttonClicked:
        _audioService.playSound(SoundType.click);
        break;
    }
  }

  /// 场景切换
  Future<void> onSceneChange(GameScene scene) async {
    if (_currentScene == scene) return;
    _currentScene = scene;

    if (!_settings.musicEnabled) return;

    switch (scene) {
      case GameScene.mainMenu:
        await _musicService.playMusic(MusicTheme.main);
        break;

      case GameScene.gameplay:
      case GameScene.aiGame:
        await _musicService.playMusic(MusicTheme.gameplay);
        break;

      case GameScene.meditationMode:
        await _musicService.playMusic(MusicTheme.relaxing);
        break;

      case GameScene.replayMode:
        await _musicService.playMusic(MusicTheme.classic);
        break;

      case GameScene.settings:
        // 保持当前音乐或降低音量
        await _musicService.setVolume(_settings.musicVolume * 0.7);
        break;
    }
  }

  /// 带音乐降低的语音播报
  bool _shouldAnnounceAiThinking() {
    final now = DateTime.now();
    final last = _lastAiThinkingAt;
    if (last != null && now.difference(last).inSeconds < 5) {
      return false;
    }
    _lastAiThinkingAt = now;
    return true;
  }

  void _enqueueAnnouncement(
    String text, {
    int priority = 0,
    bool interrupt = false,
  }) {
    if (!_settings.voiceEnabled) return;

    if (interrupt) {
      _voiceQueue.clear();
      _voiceService.stop();
    }

    final entry = _VoiceAnnouncement(
      text: text,
      priority: priority,
      interrupt: interrupt,
      timestamp: DateTime.now(),
    );

    if (_voiceQueue.isEmpty) {
      _voiceQueue.add(entry);
    } else {
      final index = _voiceQueue.indexWhere((e) => e.priority < priority);
      if (index == -1) {
        _voiceQueue.add(entry);
      } else {
        _voiceQueue.insert(index, entry);
      }
    }

    _processVoiceQueue();
  }

  Future<void> _processVoiceQueue() async {
    if (_voiceProcessing) return;
    _voiceProcessing = true;

    while (_voiceQueue.isNotEmpty) {
      final next = _voiceQueue.removeAt(0);
      await _playAnnouncement(next.text);
    }

    _voiceProcessing = false;
  }

  Future<void> _playAnnouncement(String text) async {
    if (!_settings.voiceEnabled) return;
    if (_isVoicePlaying) return;

    _isVoicePlaying = true;

    await _onVoiceStart();
    await _voiceService.speak(text);
    await Future.delayed(const Duration(milliseconds: 300));
    await _onVoiceEnd();

    _isVoicePlaying = false;
  }

  /// 语音开始时降低音乐音量
  Future<void> _onVoiceStart() async {
    if (_settings.musicEnabled && _musicService.isPlaying()) {
      await _musicService.setVolume(_originalMusicVolume * 0.3);
    }
  }

  /// 语音结束时恢复音乐音量
  Future<void> _onVoiceEnd() async {
    if (_settings.musicEnabled && _musicService.isPlaying()) {
      await _musicService.setVolume(_originalMusicVolume);
    }
  }

  /// 停止所有音频
  Future<void> stopAll() async {
    await _musicService.stopMusic();
    await _voiceService.stop();
  }

  /// 暂停所有音频
  Future<void> pauseAll() async {
    await _musicService.pauseMusic();
    await _voiceService.pause();
  }

  /// 恢复所有音频
  Future<void> resumeAll() async {
    if (_settings.musicEnabled) {
      await _musicService.resumeMusic();
    }
  }

  /// 释放资源
  Future<void> dispose() async {
    await _audioService.dispose();
    await _musicService.dispose();
    await _voiceService.dispose();
  }
}

class _VoiceAnnouncement {
  final String text;
  final int priority;
  final bool interrupt;
  final DateTime timestamp;

  _VoiceAnnouncement({
    required this.text,
    required this.priority,
    required this.interrupt,
    required this.timestamp,
  });
}
