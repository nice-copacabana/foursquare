// Generated by Qoder AI (Model: gemini-3-pro) - 2025-11-25
// Task: 音频总控制器 - 协调音效/音乐/语音三个服务,统一管理音频事件

import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import '../models/audio_settings.dart';
import '../services/audio_service.dart';
import '../services/music_service.dart';
import '../services/voice_synthesis_service.dart';
import '../services/logger_service.dart';

/// 游戏事件枚举
enum GameEvent {
  /// 选中棋子
  pieceSelected,
  
  /// 移动棋子
  pieceMoved,
  
  /// 吃子
  pieceCaptured,
  
  /// 游戏胜利
  gameWon,
  
  /// 游戏失败
  gameLost,
  
  /// 轮次切换
  turnChanged,
  
  /// AI思考中
  aiThinking,
  
  /// 非法操作
  invalidOperation,
  
  /// 按钮点击
  buttonClicked,
}

/// 游戏场景枚举
enum GameScene {
  /// 主菜单
  mainMenu,
  
  /// 普通对弈
  gameplay,
  
  /// 冥想模式
  meditationMode,
  
  /// AI对弈
  aiGame,
  
  /// 回放模式
  replayMode,
  
  /// 设置页面
  settings,
}

/// 音频总控制器
/// 
/// 职责:
/// - 协调音效、音乐、语音三个服务
/// - 管理音频冲突和优先级
/// - 统一音频配置和持久化
/// - 响应游戏事件触发对应音频
class AudioCoordinator {
  static final AudioCoordinator _instance = AudioCoordinator._internal();
  factory AudioCoordinator() => _instance;
  AudioCoordinator._internal();

  final AudioService _audioService = AudioService();
  final MusicService _musicService = MusicService();
  final VoiceSynthesisService _voiceService = VoiceSynthesisService();
  SharedPreferences? _prefs;

  AudioSettings _settings = AudioSettings.defaultSettings;
  GameScene _currentScene = GameScene.mainMenu;
  bool _isVoicePlaying = false;
  double _originalMusicVolume = 0.4;

  static const String _keyAudioSettings = 'audio_settings';

  /// 获取当前设置
  AudioSettings get settings => _settings;

  /// 初始化音频协调器
  Future<void> initialize() async {
    try {
      // 初始化SharedPreferences
      _prefs = await SharedPreferences.getInstance();
      
      // 加载设置
      await _loadSettings();

      // 初始化各服务
      await _audioService.initialize();
      await _musicService.initialize();
      await _voiceService.initialize();

      // 应用设置
      await _applySettings();

      logger.info('音频协调器初始化成功', 'AudioCoordinator');
    } catch (e) {
      logger.error('音频协调器初始化失败', 'AudioCoordinator', e);
    }
  }

  /// 加载音频设置
  Future<void> _loadSettings() async {
    try {
      final jsonStr = _prefs?.getString(_keyAudioSettings);
      if (jsonStr != null) {
        final map = jsonDecode(jsonStr) as Map<String, dynamic>;
        _settings = AudioSettings.fromMap(map);
        logger.info('已加载音频设置', 'AudioCoordinator');
      }
    } catch (e) {
      logger.warning('加载音频设置失败,使用默认值', 'AudioCoordinator');
      _settings = AudioSettings.defaultSettings;
    }
  }

  /// 保存音频设置
  Future<void> _saveSettings() async {
    try {
      final jsonStr = jsonEncode(_settings.toMap());
      await _prefs?.setString(_keyAudioSettings, jsonStr);
      logger.info('已保存音频设置', 'AudioCoordinator');
    } catch (e) {
      logger.error('保存音频设置失败', 'AudioCoordinator', e);
    }
  }

  /// 应用设置到各服务
  Future<void> _applySettings() async {
    // 音效设置
    _audioService.setEnabled(_settings.soundEnabled);
    _audioService.setVolume(_settings.soundVolume);

    // 音乐设置
    await _musicService.setEnabled(_settings.musicEnabled);
    await _musicService.setVolume(_settings.musicVolume);
    _originalMusicVolume = _settings.musicVolume;

    // 语音设置
    await _voiceService.setVolume(_settings.voiceVolume);
    await _voiceService.setSpeechRate(_settings.voiceSpeechRate);
    await _voiceService.setPitch(_settings.voicePitch);
  }

  /// 更新音频设置
  Future<void> updateSettings(AudioSettings newSettings) async {
    _settings = newSettings;
    await _applySettings();
    await _saveSettings();
  }

  /// 响应游戏事件
  void onGameEvent(GameEvent event, {Map<String, dynamic>? data}) {
    if (!_settings.soundEnabled && !_settings.voiceEnabled) return;

    switch (event) {
      case GameEvent.pieceSelected:
        _audioService.playSound(SoundType.select);
        break;

      case GameEvent.pieceMoved:
        _audioService.playSound(SoundType.move);
        if (_settings.voiceEnabled) {
          // 语音播报移动(可选)
        }
        break;

      case GameEvent.pieceCaptured:
        _audioService.playSound(SoundType.capture);
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _speakWithMusicDucking('$player吃掉对方棋子');
        }
        break;

      case GameEvent.gameWon:
        _audioService.playSound(SoundType.win);
        _musicService.playMusic(MusicTheme.victory);
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _speakWithMusicDucking('$player获胜');
        }
        break;

      case GameEvent.gameLost:
        _audioService.playSound(SoundType.lose);
        if (_settings.voiceEnabled) {
          _speakWithMusicDucking('游戏结束');
        }
        break;

      case GameEvent.turnChanged:
        if (_settings.voiceEnabled && data != null) {
          final player = data['player'] as String? ?? '';
          _speakWithMusicDucking('轮到$player');
        }
        break;

      case GameEvent.aiThinking:
        if (_settings.voiceEnabled) {
          _speakWithMusicDucking('AI正在思考');
        }
        break;

      case GameEvent.invalidOperation:
        // 可选:播放错误音效
        break;

      case GameEvent.buttonClicked:
        _audioService.playSound(SoundType.click);
        break;
    }
  }

  /// 场景切换
  Future<void> onSceneChange(GameScene scene) async {
    if (_currentScene == scene) return;
    _currentScene = scene;

    if (!_settings.musicEnabled) return;

    switch (scene) {
      case GameScene.mainMenu:
        await _musicService.playMusic(MusicTheme.main);
        break;

      case GameScene.gameplay:
      case GameScene.aiGame:
        await _musicService.playMusic(MusicTheme.gameplay);
        break;

      case GameScene.meditationMode:
        await _musicService.playMusic(MusicTheme.relaxing);
        break;

      case GameScene.replayMode:
        await _musicService.playMusic(MusicTheme.classic);
        break;

      case GameScene.settings:
        // 保持当前音乐或降低音量
        await _musicService.setVolume(_settings.musicVolume * 0.7);
        break;
    }
  }

  /// 带音乐降低的语音播报
  void _speakWithMusicDucking(String text) async {
    if (!_settings.voiceEnabled || _isVoicePlaying) return;

    _isVoicePlaying = true;

    // 降低音乐音量
    await _onVoiceStart();

    // 播报语音
    await _voiceService.speak(text);

    // 恢复音乐音量
    await Future.delayed(const Duration(milliseconds: 500));
    await _onVoiceEnd();

    _isVoicePlaying = false;
  }

  /// 语音开始时降低音乐音量
  Future<void> _onVoiceStart() async {
    if (_settings.musicEnabled && _musicService.isPlaying()) {
      await _musicService.setVolume(_originalMusicVolume * 0.3);
    }
  }

  /// 语音结束时恢复音乐音量
  Future<void> _onVoiceEnd() async {
    if (_settings.musicEnabled && _musicService.isPlaying()) {
      await _musicService.setVolume(_originalMusicVolume);
    }
  }

  /// 停止所有音频
  Future<void> stopAll() async {
    await _musicService.stopMusic();
    await _voiceService.stop();
  }

  /// 暂停所有音频
  Future<void> pauseAll() async {
    await _musicService.pauseMusic();
    await _voiceService.pause();
  }

  /// 恢复所有音频
  Future<void> resumeAll() async {
    if (_settings.musicEnabled) {
      await _musicService.resumeMusic();
    }
  }

  /// 释放资源
  Future<void> dispose() async {
    await _audioService.dispose();
    await _musicService.dispose();
    await _voiceService.dispose();
  }
}
