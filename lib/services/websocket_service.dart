// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现WebSocket服务，管理在线对战通信

import 'dart:async';
import 'dart:convert';
import 'package:web_socket_channel/web_socket_channel.dart';
import '../models/websocket_message.dart';
import '../models/message_type.dart';
import '../models/move.dart';
import '../constants/network_constants.dart';

/// WebSocket连接状态
enum ConnectionState {
  /// 已断开
  disconnected,
  
  /// 连接中
  connecting,
  
  /// 已连接
  connected,
  
  /// 重连中
  reconnecting,
}

/// WebSocket服务
/// 
/// 负责在线对战的网络通信，包括：
/// - 建立和维护WebSocket连接
/// - 发送和接收游戏消息
/// - 处理连接断开和重连
/// - 心跳包保活机制
class WebSocketService {
  static final WebSocketService _instance = WebSocketService._internal();
  factory WebSocketService() => _instance;
  WebSocketService._internal();

  WebSocketChannel? _channel;
  ConnectionState _state = ConnectionState.disconnected;
  
  final StreamController<WebSocketMessage> _messageController =
      StreamController<WebSocketMessage>.broadcast();
  
  final StreamController<ConnectionState> _stateController =
      StreamController<ConnectionState>.broadcast();

  Timer? _heartbeatTimer;
  Timer? _reconnectTimer;
  
  String? _serverUrl;
  int _reconnectAttempts = 0;

  /// 获取消息流
  Stream<WebSocketMessage> get messageStream => _messageController.stream;
  
  /// 获取连接状态流
  Stream<ConnectionState> get stateStream => _stateController.stream;
  
  /// 获取当前连接状态
  ConnectionState get state => _state;
  
  /// 是否已连接
  bool get isConnected => _state == ConnectionState.connected;

  /// 连接到服务器
  /// 
  /// [serverUrl] WebSocket服务器URL（如：ws://example.com/game）
  /// 返回是否连接成功
  Future<bool> connect(String serverUrl) async {
    if (_state == ConnectionState.connected || _state == ConnectionState.connecting) {
      print('WebSocket已连接或正在连接中');
      return _state == ConnectionState.connected;
    }

    _serverUrl = serverUrl;
    _updateState(ConnectionState.connecting);

    try {
      final uri = Uri.parse(serverUrl);
      _channel = WebSocketChannel.connect(uri);

      // 监听消息
      _channel!.stream.listen(
        _onMessage,
        onError: _onError,
        onDone: _onDisconnected,
        cancelOnError: false,
      );

      // 连接成功
      _updateState(ConnectionState.connected);
      _reconnectAttempts = 0;
      
      // 启动心跳
      _startHeartbeat();

      print('WebSocket连接成功: $serverUrl');
      return true;
    } catch (e) {
      print('WebSocket连接失败: $e');
      _updateState(ConnectionState.disconnected);
      return false;
    }
  }

  /// 断开连接
  Future<void> disconnect() async {
    _stopHeartbeat();
    _stopReconnect();
    
    await _channel?.sink.close();
    _channel = null;
    
    _updateState(ConnectionState.disconnected);
    print('WebSocket已断开连接');
  }

  /// 发送消息
  Future<void> sendMessage(WebSocketMessage message) async {
    if (!isConnected) {
      print('WebSocket未连接，无法发送消息');
      return;
    }

    try {
      final jsonString = jsonEncode(message.toJson());
      _channel?.sink.add(jsonString);
      print('发送消息: ${message.type.displayName}');
    } catch (e) {
      print('发送消息失败: $e');
    }
  }

  /// 请求匹配
  Future<void> requestMatch(String playerId) async {
    final message = WebSocketMessage.matchRequest(playerId);
    await sendMessage(message);
  }

  /// 发送移动
  Future<void> sendMove(String matchId, Move move) async {
    final moveData = {
      'from': {
        'x': move.from.x,
        'y': move.from.y,
      },
      'to': {
        'x': move.to.x,
        'y': move.to.y,
      },
      'player': move.player.name,
      'capturedPiece': move.capturedPiece != null
          ? {
              'x': move.capturedPiece!.x,
              'y': move.capturedPiece!.y,
            }
          : null,
    };

    final message = WebSocketMessage.move(
      matchId: matchId,
      moveData: moveData,
    );
    
    await sendMessage(message);
  }

  /// 取消匹配
  Future<void> cancelMatch(String playerId) async {
    final message = WebSocketMessage.cancelMatch(playerId);
    await sendMessage(message);
  }

  /// 处理接收到的消息
  void _onMessage(dynamic data) {
    try {
      final json = jsonDecode(data as String) as Map<String, dynamic>;
      final message = WebSocketMessage.fromJson(json);
      
      print('收到消息: ${message.type.displayName}');
      
      // 如果是心跳响应，不需要通知上层
      if (message.type != MessageType.heartbeat) {
        _messageController.add(message);
      }
    } catch (e) {
      print('解析消息失败: $e');
    }
  }

  /// 处理错误
  void _onError(dynamic error) {
    print('WebSocket错误: $error');
    _attemptReconnect();
  }

  /// 处理连接断开
  void _onDisconnected() {
    print('WebSocket连接已断开');
    _stopHeartbeat();
    
    if (_state != ConnectionState.disconnected) {
      _attemptReconnect();
    }
  }

  /// 尝试重连
  void _attemptReconnect() {
    if (_reconnectAttempts >= NetworkConstants.maxReconnectAttempts) {
      print('达到最大重连次数，停止重连');
      _updateState(ConnectionState.disconnected);
      return;
    }

    if (_serverUrl == null) {
      print('无服务器URL，无法重连');
      return;
    }

    _reconnectAttempts++;
    _updateState(ConnectionState.reconnecting);
    
    print('尝试重连 ($_reconnectAttempts/${NetworkConstants.maxReconnectAttempts})...');
    
    _reconnectTimer = Timer(NetworkConstants.reconnectDelay, () async {
      await connect(_serverUrl!);
    });
  }

  /// 启动心跳
  void _startHeartbeat() {
    _stopHeartbeat();
    
    _heartbeatTimer = Timer.periodic(NetworkConstants.heartbeatInterval, (timer) {
      if (isConnected) {
        final message = WebSocketMessage.heartbeat();
        sendMessage(message);
      } else {
        timer.cancel();
      }
    });
  }

  /// 停止心跳
  void _stopHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
  }

  /// 停止重连
  void _stopReconnect() {
    _reconnectTimer?.cancel();
    _reconnectTimer = null;
    _reconnectAttempts = 0;
  }

  /// 更新连接状态
  void _updateState(ConnectionState newState) {
    if (_state != newState) {
      _state = newState;
      _stateController.add(newState);
      print('连接状态变更: ${newState.toString().split('.').last}');
    }
  }

  /// 释放资源
  Future<void> dispose() async {
    await disconnect();
    await _messageController.close();
    await _stateController.close();
  }
}
