// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-11-25
// Task: 增强评估函数，添加威胁检测和防守评估

/// Board Evaluation - 棋盘评估函数
/// 
/// 职责：
/// - 评估棋盘局面优劣
/// - 为AI提供决策依据
library;

import '../models/board_state.dart';
import '../models/piece_type.dart';
import '../models/position.dart';

/// 棋盘评估器
class BoardEvaluator {
  /// 评估棋盘局面
  /// 
  /// 返回分数：
  /// - 正数表示白方优势
  /// - 负数表示黑方优势
  /// - 0表示均势
  static int evaluate(BoardState board, PieceType player) {
    int score = 0;
    
    // 1. 棋子数量差异 (最重要)
    score += _evaluatePieceCount(board, player);
    
    // 2. 位置优势
    score += _evaluatePositions(board, player);
    
    // 3. 移动能力
    score += _evaluateMobility(board, player);
    
    // 4. 三子连线威胁（新增）
    score += _evaluateThreats(board, player);
    
    // 5. 防守价值（新增）
    score += _evaluateDefense(board, player);
    
    return score;
  }
  
  /// 评估棋子数量
  static int _evaluatePieceCount(BoardState board, PieceType player) {
    final isWhite = player == PieceType.white;
    final myCount = isWhite ? board.whitePieces.length : board.blackPieces.length;
    final oppCount = isWhite ? board.blackPieces.length : board.whitePieces.length;
    
    // 每个棋子价值1000分
    return (myCount - oppCount) * 1000;
  }
  
  /// 评估棋子位置
  static int _evaluatePositions(BoardState board, PieceType player) {
    int score = 0;
    final isWhite = player == PieceType.white;
    final myPieces = isWhite ? board.whitePieces : board.blackPieces;
    
    for (final pos in myPieces) {
      // 中心位置更有价值
      score += _getPositionValue(pos);
    }
    
    return score;
  }
  
  /// 获取位置价值
  static int _getPositionValue(Position pos) {
    // 中心位置价值更高
    const centerPositions = [
      Position(1, 1), Position(1, 2),
      Position(2, 1), Position(2, 2),
    ];
    
    if (centerPositions.contains(pos)) {
      return 20;
    }
    return 10;
  }
  
  /// 评估移动能力
  static int _evaluateMobility(BoardState board, PieceType player) {
    // 可移动的棋子数量
    int mobility = 0;
    final isWhite = player == PieceType.white;
    final myPieces = isWhite ? board.whitePieces : board.blackPieces;
    
    for (final pos in myPieces) {
      final adjacent = pos.getAdjacentPositions();
      for (final adj in adjacent) {
        if (board.getPiece(adj) == PieceType.empty) {
          mobility++;
        }
      }
    }
    
    return mobility * 10;  // 从5增加到10
  }
  
  /// 评估三子连线威胁（新增）
  static int _evaluateThreats(BoardState board, PieceType player) {
    int score = 0;
    final isWhite = player == PieceType.white;
    final myPieces = isWhite ? board.whitePieces : board.blackPieces;
    
    // 检查每个方向的两子连线
    for (final piece in myPieces) {
      // 横向检查
      if (_hasTwoInRow(board, piece, 1, 0, player)) {
        score += 200; // 潜在吃子机会
      }
      // 纵向检查
      if (_hasTwoInRow(board, piece, 0, 1, player)) {
        score += 200;
      }
    }
    
    return score;
  }
  
  /// 评估防守价值（新增）
  static int _evaluateDefense(BoardState board, PieceType player) {
    int score = 0;
    final opponent = player.getOpponent();
    final isWhite = opponent == PieceType.white;
    final oppPieces = isWhite ? board.whitePieces : board.blackPieces;
    
    // 检查对手的威胁，如果有两子连线，需要防守
    for (final piece in oppPieces) {
      // 横向检查
      if (_hasTwoInRow(board, piece, 1, 0, opponent)) {
        score += 150; // 防守价值
      }
      // 纵向检查
      if (_hasTwoInRow(board, piece, 0, 1, opponent)) {
        score += 150;
      }
    }
    
    return score;
  }
  
  /// 检查指定方向是否有两子连线
  static bool _hasTwoInRow(
    BoardState board,
    Position pos,
    int dx,
    int dy,
    PieceType player,
  ) {
    // 检查一个方向
    final next1 = Position(pos.x + dx, pos.y + dy);
    if (!next1.isValid() || board.getPiece(next1) != player) {
      return false;
    }
    
    // 检查第三个位置是否可以形成威胁
    final next2 = Position(pos.x + dx * 2, pos.y + dy * 2);
    if (!next2.isValid()) {
      return false;
    }
    
    final pieceAt2 = board.getPiece(next2);
    // 如果第三个位置是空或对手棋子，就有威胁
    return pieceAt2 == PieceType.empty || pieceAt2 == player.getOpponent();
  }
}
