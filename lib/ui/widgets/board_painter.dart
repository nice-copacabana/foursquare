// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现棋盘绘制器，使用CustomPainter绘制4x4棋盘和棋子

import 'package:flutter/material.dart';
import 'dart:math' as math;
import '../../models/board_state.dart';
import '../../models/position.dart';
import '../../models/piece_type.dart';
import '../../constants/ui_constants.dart';

/// 棋盘绘制器
/// 
/// 使用CustomPainter绘制：
/// - 棋盘背景和网格线
/// - 黑白棋子
/// - 选中高亮
/// - 合法移动提示
class BoardPainter extends CustomPainter {
  final BoardState boardState;
  final Position? selectedPiece;
  final List<Position> validMoves;
  final Position? lastMoveFrom;
  final Position? lastMoveTo;
  final Position? hidePiece; // 隐藏指定位置的棋子（用于动画）

  BoardPainter({
    required this.boardState,
    this.selectedPiece,
    this.validMoves = const [],
    this.lastMoveFrom,
    this.lastMoveTo,
    this.hidePiece,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final cellSize = size.width / 4;

    // 1. 绘制背景
    _drawBackground(canvas, size);

    // 2. 绘制网格线
    _drawGrid(canvas, size, cellSize);

    // 3. 绘制最后移动标记
    if (lastMoveFrom != null && lastMoveTo != null) {
      _drawLastMove(canvas, cellSize, lastMoveFrom!, lastMoveTo!);
    }

    // 4. 绘制合法移动提示
    for (final pos in validMoves) {
      _drawMoveHint(canvas, cellSize, pos);
    }

    // 5. 绘制棋子
    for (var y = 0; y < 4; y++) {
      for (var x = 0; x < 4; x++) {
        final pos = Position(x, y);
        // 跳过需要隐藏的棋子
        if (hidePiece != null && pos == hidePiece) {
          continue;
        }
        final piece = boardState.getPiece(pos);
        if (piece != PieceType.empty) {
          _drawPiece(canvas, cellSize, pos, piece);
        }
      }
    }

    // 6. 绘制选中高亮
    if (selectedPiece != null) {
      _drawSelection(canvas, cellSize, selectedPiece!);
    }
  }

  /// 绘制背景
  void _drawBackground(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = UIConstants.boardBackgroundColor
      ..style = PaintingStyle.fill;

    canvas.drawRect(
      Rect.fromLTWH(0, 0, size.width, size.height),
      paint,
    );
  }

  /// 绘制网格线
  void _drawGrid(Canvas canvas, Size size, double cellSize) {
    final paint = Paint()
      ..color = UIConstants.boardGridColor
      ..strokeWidth = UIConstants.gridLineWidth
      ..style = PaintingStyle.stroke;

    // 绘制横线
    for (var i = 0; i <= 4; i++) {
      final y = i * cellSize;
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        paint,
      );
    }

    // 绘制竖线
    for (var i = 0; i <= 4; i++) {
      final x = i * cellSize;
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        paint,
      );
    }
  }

  /// 绘制棋子
  void _drawPiece(Canvas canvas, double cellSize, Position pos, PieceType piece) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * UIConstants.pieceRadiusRatio;

    // 绘制棋子阴影
    final shadowPaint = Paint()
      ..color = Colors.black.withValues(alpha: UIConstants.shadowOpacity)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, UIConstants.pieceShadowBlur);

    canvas.drawCircle(
      center + UIConstants.pieceShadowOffset,
      radius,
      shadowPaint,
    );

    // 绘制棋子主体
    final piecePaint = Paint()
      ..color = piece == PieceType.black ? Colors.black : Colors.white
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, piecePaint);

    // 绘制棋子边框
    final borderPaint = Paint()
      ..color = piece == PieceType.black 
          ? Colors.white.withValues(alpha: UIConstants.shadowOpacity)
          : Colors.black.withValues(alpha: UIConstants.shadowOpacity)
      ..strokeWidth = UIConstants.pieceBorderWidth
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, borderPaint);

    // 白棋添加高光效果
    if (piece == PieceType.white) {
      final highlightPaint = Paint()
        ..color = Colors.white
        ..style = PaintingStyle.fill;

      final highlightCenter = Offset(
        center.dx - radius * UIConstants.pieceHighlightOffset,
        center.dy - radius * UIConstants.pieceHighlightOffset,
      );

      canvas.drawCircle(highlightCenter, radius * UIConstants.pieceHighlightRatio, highlightPaint);
    }
  }

  /// 绘制选中高亮
  void _drawSelection(Canvas canvas, double cellSize, Position pos) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * UIConstants.selectionRadiusRatio;

    // 绘制光晕效果
    final glowPaint = Paint()
      ..color = UIConstants.selectionColor.withValues(alpha: UIConstants.selectionGlowOpacity)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, UIConstants.selectionGlowBlur)
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, glowPaint);

    // 绘制高亮圆环
    final ringPaint = Paint()
      ..color = UIConstants.selectionColor
      ..strokeWidth = UIConstants.selectionRingWidth
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, ringPaint);
  }

  /// 绘制合法移动提示
  void _drawMoveHint(Canvas canvas, double cellSize, Position pos) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * UIConstants.moveHintRadiusRatio;

    final paint = Paint()
      ..color = UIConstants.moveHintColor.withValues(alpha: UIConstants.moveHintOpacity)
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, paint);

    // 绘制边框
    final borderPaint = Paint()
      ..color = UIConstants.moveHintColor
      ..strokeWidth = UIConstants.moveHintBorderWidth
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, borderPaint);
  }

  /// 绘制最后移动标记
  void _drawLastMove(Canvas canvas, double cellSize, Position from, Position to) {
    final paint = Paint()
      ..color = UIConstants.lastMoveColor.withValues(alpha: UIConstants.lastMoveBackgroundOpacity)
      ..style = PaintingStyle.fill;

    // 标记起始位置
    final fromRect = Rect.fromLTWH(
      from.x * cellSize,
      from.y * cellSize,
      cellSize,
      cellSize,
    );
    canvas.drawRect(fromRect, paint);

    // 标记目标位置
    final toRect = Rect.fromLTWH(
      to.x * cellSize,
      to.y * cellSize,
      cellSize,
      cellSize,
    );
    canvas.drawRect(toRect, paint);

    // 绘制箭头
    final arrowPaint = Paint()
      ..color = UIConstants.lastMoveColor.withValues(alpha: UIConstants.lastMoveArrowOpacity)
      ..strokeWidth = UIConstants.lastMoveArrowWidth
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final fromCenter = Offset(
      from.x * cellSize + cellSize / 2,
      from.y * cellSize + cellSize / 2,
    );

    final toCenter = Offset(
      to.x * cellSize + cellSize / 2,
      to.y * cellSize + cellSize / 2,
    );

    canvas.drawLine(fromCenter, toCenter, arrowPaint);

    // 绘制箭头头部
    _drawArrowHead(canvas, fromCenter, toCenter, arrowPaint);
  }

  /// 绘制箭头头部
  void _drawArrowHead(Canvas canvas, Offset from, Offset to, Paint paint) {
    final arrowSize = UIConstants.arrowHeadSize;
    final angle = (to - from).direction;

    final path = Path();
    path.moveTo(to.dx, to.dy);
    path.lineTo(
      to.dx - arrowSize * (to - from).distance / 50 * 
          (to.dx - from.dx).sign * 0.5,
      to.dy - arrowSize * (to - from).distance / 50 * 
          (to.dy - from.dy).sign * 0.5,
    );

    // 简化箭头绘制
    final arrowPath = Path();
    arrowPath.moveTo(to.dx, to.dy);
    
    // 左侧箭头线
    final leftAngle = angle + 2.5;
    arrowPath.lineTo(
      to.dx - arrowSize * math.cos(leftAngle),
      to.dy - arrowSize * math.sin(leftAngle),
    );
    
    arrowPath.moveTo(to.dx, to.dy);
    
    // 右侧箭头线
    final rightAngle = angle - 2.5;
    arrowPath.lineTo(
      to.dx - arrowSize * math.cos(rightAngle),
      to.dy - arrowSize * math.sin(rightAngle),
    );

    canvas.drawPath(arrowPath, paint);
  }

  @override
  bool shouldRepaint(BoardPainter oldDelegate) {
    return boardState != oldDelegate.boardState ||
        selectedPiece != oldDelegate.selectedPiece ||
        validMoves != oldDelegate.validMoves ||
        lastMoveFrom != oldDelegate.lastMoveFrom ||
        lastMoveTo != oldDelegate.lastMoveTo;
  }
}
