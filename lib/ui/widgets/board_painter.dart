// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现棋盘绘制器，使用CustomPainter绘制4x4棋盘和棋子

import 'package:flutter/material.dart';
import '../../models/board_state.dart';
import '../../models/position.dart';
import '../../models/piece_type.dart';

/// 棋盘绘制器
/// 
/// 使用CustomPainter绘制：
/// - 棋盘背景和网格线
/// - 黑白棋子
/// - 选中高亮
/// - 合法移动提示
class BoardPainter extends CustomPainter {
  final BoardState boardState;
  final Position? selectedPiece;
  final List<Position> validMoves;
  final Position? lastMoveFrom;
  final Position? lastMoveTo;

  BoardPainter({
    required this.boardState,
    this.selectedPiece,
    this.validMoves = const [],
    this.lastMoveFrom,
    this.lastMoveTo,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final cellSize = size.width / 4;

    // 1. 绘制背景
    _drawBackground(canvas, size);

    // 2. 绘制网格线
    _drawGrid(canvas, size, cellSize);

    // 3. 绘制最后移动标记
    if (lastMoveFrom != null && lastMoveTo != null) {
      _drawLastMove(canvas, cellSize, lastMoveFrom!, lastMoveTo!);
    }

    // 4. 绘制合法移动提示
    for (final pos in validMoves) {
      _drawMoveHint(canvas, cellSize, pos);
    }

    // 5. 绘制棋子
    for (var y = 0; y < 4; y++) {
      for (var x = 0; x < 4; x++) {
        final pos = Position(x, y);
        final piece = boardState.getPiece(pos);
        if (piece != PieceType.empty) {
          _drawPiece(canvas, cellSize, pos, piece);
        }
      }
    }

    // 6. 绘制选中高亮
    if (selectedPiece != null) {
      _drawSelection(canvas, cellSize, selectedPiece!);
    }
  }

  /// 绘制背景
  void _drawBackground(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFFDEB887) // 木色背景
      ..style = PaintingStyle.fill;

    canvas.drawRect(
      Rect.fromLTWH(0, 0, size.width, size.height),
      paint,
    );
  }

  /// 绘制网格线
  void _drawGrid(Canvas canvas, Size size, double cellSize) {
    final paint = Paint()
      ..color = const Color(0xFF8B4513) // 深棕色线条
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    // 绘制横线
    for (var i = 0; i <= 4; i++) {
      final y = i * cellSize;
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        paint,
      );
    }

    // 绘制竖线
    for (var i = 0; i <= 4; i++) {
      final x = i * cellSize;
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        paint,
      );
    }
  }

  /// 绘制棋子
  void _drawPiece(Canvas canvas, double cellSize, Position pos, PieceType piece) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * 0.35;

    // 绘制棋子阴影
    final shadowPaint = Paint()
      ..color = Colors.black.withOpacity(0.3)
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 3);

    canvas.drawCircle(
      center + const Offset(2, 2),
      radius,
      shadowPaint,
    );

    // 绘制棋子主体
    final piecePaint = Paint()
      ..color = piece == PieceType.black ? Colors.black : Colors.white
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, piecePaint);

    // 绘制棋子边框
    final borderPaint = Paint()
      ..color = piece == PieceType.black 
          ? Colors.white.withOpacity(0.3)
          : Colors.black.withOpacity(0.3)
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, borderPaint);

    // 白棋添加高光效果
    if (piece == PieceType.white) {
      final highlightPaint = Paint()
        ..color = Colors.white
        ..style = PaintingStyle.fill;

      final highlightCenter = Offset(
        center.dx - radius * 0.3,
        center.dy - radius * 0.3,
      );

      canvas.drawCircle(highlightCenter, radius * 0.2, highlightPaint);
    }
  }

  /// 绘制选中高亮
  void _drawSelection(Canvas canvas, double cellSize, Position pos) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * 0.45;

    // 绘制光晕效果
    final glowPaint = Paint()
      ..color = Colors.amber.withOpacity(0.3)
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8)
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, glowPaint);

    // 绘制高亮圆环
    final ringPaint = Paint()
      ..color = Colors.amber
      ..strokeWidth = 3.0
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, ringPaint);
  }

  /// 绘制合法移动提示
  void _drawMoveHint(Canvas canvas, double cellSize, Position pos) {
    final center = Offset(
      pos.x * cellSize + cellSize / 2,
      pos.y * cellSize + cellSize / 2,
    );
    final radius = cellSize * 0.15;

    final paint = Paint()
      ..color = Colors.green.withOpacity(0.5)
      ..style = PaintingStyle.fill;

    canvas.drawCircle(center, radius, paint);

    // 绘制边框
    final borderPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(center, radius, borderPaint);
  }

  /// 绘制最后移动标记
  void _drawLastMove(Canvas canvas, double cellSize, Position from, Position to) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(0.2)
      ..style = PaintingStyle.fill;

    // 标记起始位置
    final fromRect = Rect.fromLTWH(
      from.x * cellSize,
      from.y * cellSize,
      cellSize,
      cellSize,
    );
    canvas.drawRect(fromRect, paint);

    // 标记目标位置
    final toRect = Rect.fromLTWH(
      to.x * cellSize,
      to.y * cellSize,
      cellSize,
      cellSize,
    );
    canvas.drawRect(toRect, paint);

    // 绘制箭头
    final arrowPaint = Paint()
      ..color = Colors.blue.withOpacity(0.6)
      ..strokeWidth = 3.0
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final fromCenter = Offset(
      from.x * cellSize + cellSize / 2,
      from.y * cellSize + cellSize / 2,
    );

    final toCenter = Offset(
      to.x * cellSize + cellSize / 2,
      to.y * cellSize + cellSize / 2,
    );

    canvas.drawLine(fromCenter, toCenter, arrowPaint);

    // 绘制箭头头部
    _drawArrowHead(canvas, fromCenter, toCenter, arrowPaint);
  }

  /// 绘制箭头头部
  void _drawArrowHead(Canvas canvas, Offset from, Offset to, Paint paint) {
    const arrowSize = 10.0;
    final angle = (to - from).direction;

    final path = Path();
    path.moveTo(to.dx, to.dy);
    path.lineTo(
      to.dx - arrowSize * (to - from).distance / 50 * 
          (to.dx - from.dx).sign * 0.5,
      to.dy - arrowSize * (to - from).distance / 50 * 
          (to.dy - from.dy).sign * 0.5,
    );

    // 简化箭头绘制
    final arrowPath = Path();
    arrowPath.moveTo(to.dx, to.dy);
    
    // 左侧箭头线
    final leftAngle = angle + 2.5;
    arrowPath.lineTo(
      to.dx - arrowSize * (leftAngle.cos),
      to.dy - arrowSize * (leftAngle.sin),
    );
    
    arrowPath.moveTo(to.dx, to.dy);
    
    // 右侧箭头线
    final rightAngle = angle - 2.5;
    arrowPath.lineTo(
      to.dx - arrowSize * (rightAngle.cos),
      to.dy - arrowSize * (rightAngle.sin),
    );

    canvas.drawPath(arrowPath, paint);
  }

  @override
  bool shouldRepaint(BoardPainter oldDelegate) {
    return boardState != oldDelegate.boardState ||
        selectedPiece != oldDelegate.selectedPiece ||
        validMoves != oldDelegate.validMoves ||
        lastMoveFrom != oldDelegate.lastMoveFrom ||
        lastMoveTo != oldDelegate.lastMoveTo;
  }
}
