// Generated by Qoder AI (Model: gemini-3-pro) - 2025-11-24
// Task: 创建自定义游戏图标组件，正确绘制5×5网格线的4×4棋盘

import 'package:flutter/material.dart';

/// 四子游戏图标组件
/// 
/// 绘制5条横线×5条竖线，形成4×4格子的棋盘
/// 棋子放置在格子中心而非交叉点
class GameIcon extends StatelessWidget {
  final double size;
  final Color? gridColor;
  final Color? backgroundColor;
  final bool showPieces;

  const GameIcon({
    super.key,
    this.size = 60,
    this.gridColor,
    this.backgroundColor,
    this.showPieces = true,
  });

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(size, size),
      painter: _GameIconPainter(
        gridColor: gridColor ?? Colors.white,
        backgroundColor: backgroundColor,
        showPieces: showPieces,
      ),
    );
  }
}

/// 游戏图标绘制器
class _GameIconPainter extends CustomPainter {
  final Color gridColor;
  final Color? backgroundColor;
  final bool showPieces;

  _GameIconPainter({
    required this.gridColor,
    this.backgroundColor,
    required this.showPieces,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 绘制背景
    if (backgroundColor != null) {
      final bgPaint = Paint()
        ..color = backgroundColor!
        ..style = PaintingStyle.fill;
      canvas.drawRect(Offset.zero & size, bgPaint);
    }

    // 计算网格参数：留出10%边距
    final margin = size.width * 0.1;
    final gridSize = size.width - 2 * margin;
    final cellSize = gridSize / 4; // 4个格子
    
    final gridPaint = Paint()
      ..color = gridColor
      ..strokeWidth = size.width / 40
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    // 绘制5条横线和5条竖线（形成4×4格子）
    for (var i = 0; i < 5; i++) {
      final offset = margin + i * cellSize;
      
      // 横线
      canvas.drawLine(
        Offset(margin, offset),
        Offset(size.width - margin, offset),
        gridPaint,
      );
      
      // 竖线
      canvas.drawLine(
        Offset(offset, margin),
        Offset(offset, size.height - margin),
        gridPaint,
      );
    }

    // 绘制示例棋子（放在格子中心）
    if (showPieces) {
      final pieceRadius = cellSize * 0.3;
      
      // 黑色棋子（顶部行）
      final blackPositions = [
        (0, 0), (0, 1), (0, 2), (0, 3),
      ];
      
      for (final (row, col) in blackPositions) {
        final center = Offset(
          margin + (col + 0.5) * cellSize,
          margin + (row + 0.5) * cellSize,
        );
        
        // 绘制黑色棋子
        final blackPaint = Paint()
          ..color = Colors.black
          ..style = PaintingStyle.fill;
        canvas.drawCircle(center, pieceRadius, blackPaint);
        
        // 绘制边框
        final borderPaint = Paint()
          ..color = Colors.white.withValues(alpha: 0.5)
          ..strokeWidth = size.width / 80
          ..style = PaintingStyle.stroke;
        canvas.drawCircle(center, pieceRadius, borderPaint);
      }
      
      // 白色棋子（底部行）
      final whitePositions = [
        (3, 0), (3, 1), (3, 2), (3, 3),
      ];
      
      for (final (row, col) in whitePositions) {
        final center = Offset(
          margin + (col + 0.5) * cellSize,
          margin + (row + 0.5) * cellSize,
        );
        
        // 绘制白色棋子
        final whitePaint = Paint()
          ..color = Colors.white
          ..style = PaintingStyle.fill;
        canvas.drawCircle(center, pieceRadius, whitePaint);
        
        // 绘制边框
        final borderPaint = Paint()
          ..color = Colors.black.withValues(alpha: 0.3)
          ..strokeWidth = size.width / 80
          ..style = PaintingStyle.stroke;
        canvas.drawCircle(center, pieceRadius, borderPaint);
      }
    }
  }

  @override
  bool shouldRepaint(_GameIconPainter oldDelegate) {
    return oldDelegate.gridColor != gridColor ||
        oldDelegate.backgroundColor != backgroundColor ||
        oldDelegate.showPieces != showPieces;
  }
}
