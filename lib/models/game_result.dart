// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现游戏结果模型，记录游戏结束状态和统计信息

import 'package:equatable/equatable.dart';
import 'piece_type.dart';

/// 游戏状态
enum GameStatus {
  /// 游戏进行中
  ongoing,
  
  /// 黑方胜利
  blackWin,
  
  /// 白方胜利
  whiteWin,
  
  /// 超时
  timeout,
  
  /// 弃局
  abandoned,
}

extension GameStatusExtension on GameStatus {
  /// 游戏是否结束
  bool get isGameOver {
    return this != GameStatus.ongoing;
  }

  /// 获取显示文本
  String getDisplayText() {
    switch (this) {
      case GameStatus.ongoing:
        return '进行中';
      case GameStatus.blackWin:
        return '黑方胜利';
      case GameStatus.whiteWin:
        return '白方胜利';
      case GameStatus.timeout:
        return '超时';
      case GameStatus.abandoned:
        return '弃局';
    }
  }
}

/// 游戏结果
/// 
/// 记录游戏结束时的完整信息，包括：
/// - 游戏状态
/// - 胜者
/// - 胜负原因
/// - 总步数
/// - 对局时长
class GameResult extends Equatable {
  /// 游戏状态
  final GameStatus status;
  
  /// 胜者（可能为null，如弃局）
  final PieceType? winner;
  
  /// 胜负原因
  final String reason;
  
  /// 总步数
  final int moveCount;
  
  /// 对局时长
  final Duration duration;

  const GameResult({
    required this.status,
    this.winner,
    required this.reason,
    required this.moveCount,
    required this.duration,
  });

  /// 创建黑方胜利结果
  factory GameResult.blackWin({
    required String reason,
    required int moveCount,
    required Duration duration,
  }) {
    return GameResult(
      status: GameStatus.blackWin,
      winner: PieceType.black,
      reason: reason,
      moveCount: moveCount,
      duration: duration,
    );
  }

  /// 创建白方胜利结果
  factory GameResult.whiteWin({
    required String reason,
    required int moveCount,
    required Duration duration,
  }) {
    return GameResult(
      status: GameStatus.whiteWin,
      winner: PieceType.white,
      reason: reason,
      moveCount: moveCount,
      duration: duration,
    );
  }

  /// 创建超时结果
  factory GameResult.timeout({
    required PieceType timeoutPlayer,
    required int moveCount,
    required Duration duration,
  }) {
    return GameResult(
      status: GameStatus.timeout,
      winner: timeoutPlayer.getOpponent(),
      reason: '${timeoutPlayer.getDisplayName()}超时',
      moveCount: moveCount,
      duration: duration,
    );
  }

  /// 创建弃局结果
  factory GameResult.abandoned({
    required PieceType abandonedPlayer,
    required int moveCount,
    required Duration duration,
  }) {
    return GameResult(
      status: GameStatus.abandoned,
      winner: abandonedPlayer.getOpponent(),
      reason: '${abandonedPlayer.getDisplayName()}认输',
      moveCount: moveCount,
      duration: duration,
    );
  }

  /// 游戏是否结束
  bool get isGameOver => status.isGameOver;

  /// 获取结果摘要文本
  String getSummary() {
    final buffer = StringBuffer();
    buffer.writeln(status.getDisplayText());
    if (winner != null) {
      buffer.writeln('获胜方: ${winner!.getDisplayName()}');
    }
    buffer.writeln('原因: $reason');
    buffer.writeln('总步数: $moveCount');
    buffer.writeln('用时: ${_formatDuration(duration)}');
    return buffer.toString();
  }

  /// 格式化时长
  String _formatDuration(Duration duration) {
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    final seconds = duration.inSeconds % 60;

    if (hours > 0) {
      return '$hours小时$minutes分$seconds秒';
    } else if (minutes > 0) {
      return '$minutes分$seconds秒';
    } else {
      return '$seconds秒';
    }
  }

  /// 转换为Map（用于序列化）
  Map<String, dynamic> toJson() {
    return {
      'status': status.name,
      'winner': winner?.name,
      'reason': reason,
      'moveCount': moveCount,
      'duration': duration.inMilliseconds,
    };
  }

  /// 从Map创建（用于反序列化）
  factory GameResult.fromJson(Map<String, dynamic> json) {
    return GameResult(
      status: GameStatus.values.firstWhere(
        (e) => e.name == json['status'],
      ),
      winner: json['winner'] != null
          ? PieceType.values.firstWhere(
              (e) => e.name == json['winner'],
            )
          : null,
      reason: json['reason'] as String,
      moveCount: json['moveCount'] as int,
      duration: Duration(milliseconds: json['duration'] as int),
    );
  }

  @override
  List<Object?> get props => [status, winner, reason, moveCount, duration];

  @override
  String toString() {
    return 'GameResult(status: $status, winner: $winner, '
        'reason: $reason, moves: $moveCount, duration: $duration)';
  }
}
