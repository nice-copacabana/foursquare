// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现游戏保存数据模型，支持游戏状态的序列化和反序列化

/// Game Save - 游戏存档模型
/// 
/// 职责：
/// - 保存完整的游戏状态
/// - 支持JSON序列化/反序列化
/// - 用于游戏中途退出后继续
library;

import 'package:equatable/equatable.dart';
import '../bloc/game_event.dart';
import 'board_state.dart';
import 'move.dart';
import 'position.dart';
import 'piece_type.dart';

/// 游戏存档数据模型
class GameSave extends Equatable {
  final String id;
  final DateTime saveTime;
  final BoardStateData boardState;
  final List<MoveData> moveHistory;
  final String currentPlayer; // 'black' or 'white'
  final String mode; // 'pvp' or 'pve'
  final String? aiDifficulty; // 'easy', 'medium', 'hard'

  const GameSave({
    required this.id,
    required this.saveTime,
    required this.boardState,
    required this.moveHistory,
    required this.currentPlayer,
    required this.mode,
    this.aiDifficulty,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'saveTime': saveTime.toIso8601String(),
        'boardState': boardState.toJson(),
        'moveHistory': moveHistory.map((m) => m.toJson()).toList(),
        'currentPlayer': currentPlayer,
        'mode': mode,
        'aiDifficulty': aiDifficulty,
      };

  factory GameSave.fromJson(Map<String, dynamic> json) {
    return GameSave(
      id: json['id'] as String,
      saveTime: DateTime.parse(json['saveTime'] as String),
      boardState: BoardStateData.fromJson(
        Map<String, dynamic>.from(json['boardState']),
      ),
      moveHistory: (json['moveHistory'] as List)
          .map((m) => MoveData.fromJson(Map<String, dynamic>.from(m)))
          .toList(),
      currentPlayer: json['currentPlayer'] as String,
      mode: json['mode'] as String,
      aiDifficulty: json['aiDifficulty'] as String?,
    );
  }

  @override
  List<Object?> get props => [
        id,
        saveTime,
        boardState,
        moveHistory,
        currentPlayer,
        mode,
        aiDifficulty,
      ];
}

/// 棋盘状态数据（可序列化）
class BoardStateData extends Equatable {
  final List<List<String>> grid; // 'black', 'white', 'empty'
  final List<PositionData> blackPieces;
  final List<PositionData> whitePieces;

  const BoardStateData({
    required this.grid,
    required this.blackPieces,
    required this.whitePieces,
  });

  Map<String, dynamic> toJson() => {
        'grid': grid,
        'blackPieces': blackPieces.map((p) => p.toJson()).toList(),
        'whitePieces': whitePieces.map((p) => p.toJson()).toList(),
      };

  factory BoardStateData.fromJson(Map<String, dynamic> json) {
    return BoardStateData(
      grid: (json['grid'] as List)
          .map((row) => (row as List).map((cell) => cell as String).toList())
          .toList(),
      blackPieces: (json['blackPieces'] as List)
          .map((p) => PositionData.fromJson(Map<String, dynamic>.from(p)))
          .toList(),
      whitePieces: (json['whitePieces'] as List)
          .map((p) => PositionData.fromJson(Map<String, dynamic>.from(p)))
          .toList(),
    );
  }

  factory BoardStateData.fromBoardState(BoardState state) {
    return BoardStateData(
      grid: state.grid
          .map((row) => row.map((piece) => _pieceTypeToString(piece)).toList())
          .toList(),
      blackPieces:
          state.blackPieces.map((p) => PositionData.fromPosition(p)).toList(),
      whitePieces:
          state.whitePieces.map((p) => PositionData.fromPosition(p)).toList(),
    );
  }

  BoardState toBoardState(PieceType currentPlayer) {
    return BoardState(
      grid: grid
          .map((row) => row.map((cell) => _stringToPieceType(cell)).toList())
          .toList(),
      blackPieces: blackPieces.map((p) => p.toPosition()).toList(),
      whitePieces: whitePieces.map((p) => p.toPosition()).toList(),
      currentPlayer: currentPlayer,
    );
  }

  static String _pieceTypeToString(PieceType type) {
    switch (type) {
      case PieceType.black:
        return 'black';
      case PieceType.white:
        return 'white';
      case PieceType.empty:
        return 'empty';
    }
  }

  static PieceType _stringToPieceType(String str) {
    switch (str) {
      case 'black':
        return PieceType.black;
      case 'white':
        return PieceType.white;
      default:
        return PieceType.empty;
    }
  }

  @override
  List<Object?> get props => [grid, blackPieces, whitePieces];
}

/// 位置数据（可序列化）
class PositionData extends Equatable {
  final int x;
  final int y;

  const PositionData({
    required this.x,
    required this.y,
  });

  Map<String, dynamic> toJson() => {
        'x': x,
        'y': y,
      };

  factory PositionData.fromJson(Map<String, dynamic> json) {
    return PositionData(
      x: json['x'] as int,
      y: json['y'] as int,
    );
  }

  factory PositionData.fromPosition(Position pos) {
    return PositionData(x: pos.x, y: pos.y);
  }

  Position toPosition() {
    return Position(x, y);
  }

  @override
  List<Object?> get props => [x, y];
}

/// 移动数据（可序列化）
class MoveData extends Equatable {
  final PositionData from;
  final PositionData to;
  final PositionData? capturedPosition;
  final String? capturedPiece; // 'black' or 'white'

  const MoveData({
    required this.from,
    required this.to,
    this.capturedPosition,
    this.capturedPiece,
  });

  Map<String, dynamic> toJson() => {
        'from': from.toJson(),
        'to': to.toJson(),
        'capturedPosition': capturedPosition?.toJson(),
        'capturedPiece': capturedPiece,
      };

  factory MoveData.fromJson(Map<String, dynamic> json) {
    return MoveData(
      from: PositionData.fromJson(Map<String, dynamic>.from(json['from'])),
      to: PositionData.fromJson(Map<String, dynamic>.from(json['to'])),
      capturedPosition: json['capturedPosition'] != null
          ? PositionData.fromJson(
              Map<String, dynamic>.from(json['capturedPosition']),)
          : null,
      capturedPiece: json['capturedPiece'] as String?,
    );
  }

  factory MoveData.fromMove(Move move) {
    return MoveData(
      from: PositionData.fromPosition(move.from),
      to: PositionData.fromPosition(move.to),
      capturedPosition: move.capturedPiece != null
          ? PositionData.fromPosition(move.capturedPiece!)
          : null,
      capturedPiece: BoardStateData._pieceTypeToString(move.player),
    );
  }

  Move toMove() {
    return Move(
      from: from.toPosition(),
      to: to.toPosition(),
      player: capturedPiece != null
          ? BoardStateData._stringToPieceType(capturedPiece!)
          : PieceType.black,
      capturedPiece: capturedPosition?.toPosition(),
      timestamp: DateTime.now(),
    );
  }

  @override
  List<Object?> get props => [from, to, capturedPosition, capturedPiece];
}

/// 游戏模式转换扩展
extension GameModeExtensions on GameMode {
  String toJson() {
    switch (this) {
      case GameMode.pvp:
        return 'pvp';
      case GameMode.pve:
        return 'pve';
      case GameMode.online:
        return 'online';
    }
  }

  static GameMode fromJson(String json) {
    switch (json) {
      case 'pvp':
        return GameMode.pvp;
      case 'pve':
        return GameMode.pve;
      case 'online':
        return GameMode.online;
      default:
        return GameMode.pvp;
    }
  }
}
