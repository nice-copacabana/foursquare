// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现棋盘状态模型，维护4x4棋盘的完整状态

import 'package:equatable/equatable.dart';
import 'position.dart';
import 'piece_type.dart';

/// 棋盘状态
/// 
/// 维护棋盘当前状态，包括：
/// - 4x4棋盘网格
/// - 黑方和白方棋子位置列表
/// - 当前玩家
class BoardState extends Equatable {
  /// 4x4棋盘网格
  final List<List<PieceType>> grid;
  
  /// 黑方棋子位置列表
  final List<Position> blackPieces;
  
  /// 白方棋子位置列表
  final List<Position> whitePieces;
  
  /// 当前玩家
  final PieceType currentPlayer;

  const BoardState({
    required this.grid,
    required this.blackPieces,
    required this.whitePieces,
    required this.currentPlayer,
  });

  /// 创建初始棋盘状态
  /// 
  /// 黑方初始位置: (0,0), (0,1), (0,2), (0,3)
  /// 白方初始位置: (3,0), (3,1), (3,2), (3,3)
  /// 当前玩家: 黑方（先手）
  factory BoardState.initial() {
    final grid = List.generate(
      4,
      (y) => List.generate(
        4,
        (x) {
          if (y == 0) return PieceType.black;
          if (y == 3) return PieceType.white;
          return PieceType.empty;
        },
      ),
    );

    final blackPieces = [
      const Position(0, 0),
      const Position(1, 0),
      const Position(2, 0),
      const Position(3, 0),
    ];

    final whitePieces = [
      const Position(0, 3),
      const Position(1, 3),
      const Position(2, 3),
      const Position(3, 3),
    ];

    return BoardState(
      grid: grid,
      blackPieces: blackPieces,
      whitePieces: whitePieces,
      currentPlayer: PieceType.black,
    );
  }

  /// 获取指定位置的棋子
  PieceType getPiece(Position pos) {
    if (!pos.isValid()) {
      return PieceType.empty;
    }
    return grid[pos.y][pos.x];
  }

  /// 设置指定位置的棋子
  BoardState setPiece(Position pos, PieceType piece) {
    if (!pos.isValid()) {
      return this;
    }

    final newGrid = _copyGrid();
    newGrid[pos.y][pos.x] = piece;

    final newBlackPieces = List<Position>.from(blackPieces);
    final newWhitePieces = List<Position>.from(whitePieces);

    // 更新棋子列表
    if (piece == PieceType.black && !newBlackPieces.contains(pos)) {
      newBlackPieces.add(pos);
      newWhitePieces.remove(pos);
    } else if (piece == PieceType.white && !newWhitePieces.contains(pos)) {
      newWhitePieces.add(pos);
      newBlackPieces.remove(pos);
    } else if (piece == PieceType.empty) {
      newBlackPieces.remove(pos);
      newWhitePieces.remove(pos);
    }

    return BoardState(
      grid: newGrid,
      blackPieces: newBlackPieces,
      whitePieces: newWhitePieces,
      currentPlayer: currentPlayer,
    );
  }

  /// 判断位置是否为空
  bool isEmpty(Position pos) {
    return getPiece(pos) == PieceType.empty;
  }

  /// 移动棋子
  BoardState movePiece(Position from, Position to) {
    if (!from.isValid() || !to.isValid()) {
      return this;
    }

    final piece = getPiece(from);
    if (piece == PieceType.empty) {
      return this;
    }

    return setPiece(from, PieceType.empty).setPiece(to, piece);
  }

  /// 移除棋子
  BoardState removePiece(Position pos) {
    return setPiece(pos, PieceType.empty);
  }

  /// 获取指定类型棋子数量
  int getPieceCount(PieceType type) {
    switch (type) {
      case PieceType.black:
        return blackPieces.length;
      case PieceType.white:
        return whitePieces.length;
      case PieceType.empty:
        int count = 0;
        for (var row in grid) {
          count += row.where((p) => p == PieceType.empty).length;
        }
        return count;
    }
  }

  /// 获取指定类型所有棋子位置
  List<Position> getAllPieces(PieceType type) {
    switch (type) {
      case PieceType.black:
        return List.from(blackPieces);
      case PieceType.white:
        return List.from(whitePieces);
      case PieceType.empty:
        final positions = <Position>[];
        for (var y = 0; y < 4; y++) {
          for (var x = 0; x < 4; x++) {
            final pos = Position(x, y);
            if (isEmpty(pos)) {
              positions.add(pos);
            }
          }
        }
        return positions;
    }
  }

  /// 切换当前玩家
  BoardState switchPlayer() {
    return copyWith(
      currentPlayer: currentPlayer.getOpponent(),
    );
  }

  /// 深拷贝棋盘网格
  List<List<PieceType>> _copyGrid() {
    return List.generate(
      4,
      (y) => List.from(grid[y]),
    );
  }

  /// 创建副本
  BoardState copyWith({
    List<List<PieceType>>? grid,
    List<Position>? blackPieces,
    List<Position>? whitePieces,
    PieceType? currentPlayer,
  }) {
    return BoardState(
      grid: grid ?? _copyGrid(),
      blackPieces: blackPieces ?? List.from(this.blackPieces),
      whitePieces: whitePieces ?? List.from(this.whitePieces),
      currentPlayer: currentPlayer ?? this.currentPlayer,
    );
  }

  /// 获取棋盘的文本表示（用于调试）
  String toDebugString() {
    final buffer = StringBuffer();
    buffer.writeln('  0 1 2 3');
    for (var y = 0; y < 4; y++) {
      buffer.write('$y ');
      for (var x = 0; x < 4; x++) {
        buffer.write('${grid[y][x].getSymbol()} ');
      }
      buffer.writeln();
    }
    buffer.writeln('当前玩家: ${currentPlayer.getDisplayName()}');
    buffer.writeln('黑方棋子数: ${blackPieces.length}');
    buffer.writeln('白方棋子数: ${whitePieces.length}');
    return buffer.toString();
  }

  @override
  List<Object?> get props => [grid, blackPieces, whitePieces, currentPlayer];
}
