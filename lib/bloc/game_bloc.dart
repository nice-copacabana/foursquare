/// Game BLoC - 游戏业务逻辑组件
/// 
/// 职责：
/// - 处理所有游戏事件
/// - 管理游戏状态转换
/// - 集成游戏引擎
/// - 协调音频和存储服务
/// 
/// 核心功能：
/// - 棋子选择和移动
/// - 游戏流程控制
/// - 撤销/重做
/// - 保存/加载游戏
library;

import 'package:flutter_bloc/flutter_bloc.dart';
import '../models/board_state.dart';
import '../models/piece_type.dart';
import '../models/position.dart';
import '../models/game_result.dart';
import '../models/game_save.dart';
import '../engine/game_engine.dart';
import '../engine/move_validator.dart';
import '../services/audio_coordinator.dart' as audio;
import '../services/storage_service.dart';
import '../services/logger_service.dart';
// import '../services/voice_recognition_service.dart'; // 暂时禁用
// import '../services/voice_synthesis_service.dart'; // 暂时禁用
import '../ai/ai_player.dart';
import '../ai/minimax_ai.dart';
import '../ai/voice_command_parser.dart';
import 'game_event.dart';
import 'game_state.dart';
import 'dart:math' as math;

/// 游戏BLoC
class GameBloc extends Bloc<GameEvent, GameState> {
  final GameEngine _gameEngine;
  final MoveValidator _moveValidator;
  final audio.AudioCoordinator _audioCoordinator;
  final StorageService _storageService;
  // final VoiceRecognitionService _voiceRecognitionService; // 暂时禁用
  // final VoiceSynthesisService _voiceSynthesisService; // 暂时禁用

  GameBloc({
    GameEngine? gameEngine,
    MoveValidator? moveValidator,
    audio.AudioCoordinator? audioCoordinator,
    StorageService? storageService,
    // VoiceRecognitionService? voiceRecognitionService, // 暂时禁用
    // VoiceSynthesisService? voiceSynthesisService, // 暂时禁用
  })  : _gameEngine = gameEngine ?? GameEngine(),
        _moveValidator = moveValidator ?? MoveValidator(),
        _audioCoordinator = audioCoordinator ?? audio.AudioCoordinator(),
        _storageService = storageService ?? StorageService(),
        // _voiceRecognitionService = voiceRecognitionService ?? VoiceRecognitionService(), // 暂时禁用
        // _voiceSynthesisService = voiceSynthesisService ?? VoiceSynthesisService(), // 暂时禁用
        super(GameInitial()) {
    _audioCoordinator.initialize();

    // 注册事件处理器
    on<NewGameEvent>(_onNewGame);
    on<RestartGameEvent>(_onRestartGame);
    on<SelectPieceEvent>(_onSelectPiece);
    on<MovePieceEvent>(_onMovePiece);
    on<DeselectPieceEvent>(_onDeselectPiece);
    on<UndoMoveEvent>(_onUndoMove);
    on<RedoMoveEvent>(_onRedoMove);
    on<AIPlayEvent>(_onAIPlay);
    on<SaveGameEvent>(_onSaveGame);
    on<LoadGameEvent>(_onLoadGame);
    on<SettingsChangedEvent>(_onSettingsChanged);
    
    // 语音控制事件处理器（暂时禁用）
    // on<VoiceControlToggledEvent>(_onVoiceControlToggled);
    // on<VoiceCommandReceivedEvent>(_onVoiceCommandReceived);
    // on<VoiceAnnouncementRequestedEvent>(_onVoiceAnnouncementRequested);
  }

  /// 处理新游戏事件
  Future<void> _onNewGame(NewGameEvent event, Emitter<GameState> emit) async {
    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
    
    // 切换到游戏音乐
    await _audioCoordinator.onSceneChange(
      event.mode == GameMode.pve ? audio.GameScene.aiGame : audio.GameScene.gameplay,
    );

    // Generated by Qoder AI (Model: gemini-3-pro) - 2025-11-25
    // Task: 实现双人对战先手随机逻辑
    
    // 双人对战模式下随机决定先手方
    PieceType? firstPlayer;
    if (event.mode == GameMode.pvp) {
      final random = math.Random();
      firstPlayer = random.nextBool() ? PieceType.black : PieceType.white;
    }

    emit(GamePlaying(
      boardState: BoardState.initial(),
      mode: event.mode,
      aiDifficulty: event.aiDifficulty,
      moveHistory: const [],
      firstPlayer: firstPlayer,
    ),);

    // 如果是AI模式且AI先手，触发AI移动
    if (event.mode == GameMode.pve && state.currentPlayer == PieceType.white) {
      add(const AIPlayEvent());
    }
  }

  /// 处理重新开始事件
  Future<void> _onRestartGame(RestartGameEvent event, Emitter<GameState> emit) async {
    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);

    final currentMode = state.mode;
    await _audioCoordinator.onSceneChange(
      currentMode == GameMode.pve ? audio.GameScene.aiGame : audio.GameScene.gameplay,
    );
    final currentAIDifficulty = state is GamePlaying 
        ? (state as GamePlaying).aiDifficulty 
        : null;

    emit(GamePlaying(
      boardState: BoardState.initial(),
      mode: currentMode,
      aiDifficulty: currentAIDifficulty,
      moveHistory: const [],
    ),);

    // 如果是AI模式且AI先手，触发AI移动
    if (currentMode == GameMode.pve && state.currentPlayer == PieceType.white) {
      add(const AIPlayEvent());
    }
  }

  /// 处理选中棋子事件
  Future<void> _onSelectPiece(SelectPieceEvent event, Emitter<GameState> emit) async {
    // 只在游戏进行中且不是AI回合时处理
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;
    
    if (playing.isAITurn || playing.isAIThinking) return;

    final piece = playing.boardState.getPiece(event.position);

    // 只能选中当前玩家的棋子
    if (piece != playing.currentPlayer) return;

    _audioCoordinator.onGameEvent(audio.GameEvent.pieceSelected);

    // 获取该棋子的合法移动
    final validMoves = _moveValidator.getValidMoves(
      playing.boardState,
      event.position,
    );

    emit(playing.copyWith(
      selectedPiece: event.position,
      validMoves: validMoves,
    ),);
  }

  /// 处理移动棋子事件
  Future<void> _onMovePiece(MovePieceEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (playing.isAIThinking) return;

    // 验证移动是否合法
    if (!_moveValidator.isValidMove(playing.boardState, event.from, event.to)) {
      return;
    }

    // 执行移动
    final result = _gameEngine.executeMove(playing.boardState, event.from, event.to);

    if (!result.success) {
      return;
    }

    // 播放音效
    if (result.captured != null) {
      _audioCoordinator.onGameEvent(
        audio.GameEvent.pieceCaptured,
        data: {'player': playing.currentPlayer.getDisplayName()},
      );
    } else {
      _audioCoordinator.onGameEvent(audio.GameEvent.pieceMoved);
    }

    // 移动记录已经在executeMove中创建，直接使用
    final move = result.move!;

    // 更新移动历史
    final newMoveHistory = [...playing.moveHistory, move];

    // 检查游戏是否结束
    if (result.gameResult != null) {
      // ????/????
      final winner = result.gameResult!.winner;
      if (playing.mode == GameMode.pve) {
        if (winner == PieceType.black) {
          _audioCoordinator.onGameEvent(
            audio.GameEvent.gameWon,
            data: {'player': winner.getDisplayName()},
          );
        } else if (winner == PieceType.white) {
          _audioCoordinator.onGameEvent(
            audio.GameEvent.gameLost,
            data: {'player': winner.getDisplayName()},
          );
        }
      } else if (winner != null) {
        _audioCoordinator.onGameEvent(
          audio.GameEvent.gameWon,
          data: {'player': winner.getDisplayName()},
        );
      }

      await _updateStatistics(result.gameResult!, newMoveHistory.length, playing);

      emit(GameOver(
        boardState: result.newBoard!,
        mode: playing.mode,
        gameResult: result.gameResult!,
        moveHistory: newMoveHistory,
        lastMove: move,
        aiDifficulty: playing.aiDifficulty,
      ),);
      return;
    }

    // 游戏继续，更新状态
    // 执行移动后清空撤销栈（因为新移动会使之前的重做无效）
    emit(playing.copyWith(
      boardState: result.newBoard!,
      selectedPiece: null,
      clearSelectedPiece: true,
      validMoves: const [],
      moveHistory: newMoveHistory,
      undoStack: const [], // 清空撤销栈
      lastMove: move,
      lastCapturedPosition: result.captured,
      clearLastCapturedPosition: result.captured == null,
    ),);

    // 如果是AI模式且轮到AI，触发AI移动
    _audioCoordinator.onGameEvent(
      audio.GameEvent.turnChanged,
      data: {'player': result.newBoard!.currentPlayer.getDisplayName()},
    );

    if (playing.mode == GameMode.pve && result.newBoard!.currentPlayer == PieceType.white) {
      add(const AIPlayEvent());
    }
    
    // 如果语音控制开启且是对手移动，触发语音播报
    if (playing.isVoiceControlEnabled && 
        playing.currentPlayer != result.newBoard!.currentPlayer) {
      add(VoiceAnnouncementRequestedEvent(
        from: event.from,
        to: event.to,
        isCaptureMove: result.captured != null,
      ));
    }
  }

  /// 处理取消选中事件
  Future<void> _onDeselectPiece(DeselectPieceEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    emit(playing.copyWith(
      selectedPiece: null,
      clearSelectedPiece: true,
      validMoves: const [],
    ),);
  }

  /// 处理撤销移动事件
  Future<void> _onUndoMove(UndoMoveEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (!playing.canUndo || playing.isAIThinking) return;

    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);

    // 计算要撤销的步数（AI模式撤销2步，双人模式按指定步数）
    final stepsToUndo = playing.mode == GameMode.pve ? 2 : event.steps;
    
    // 限制最多撤销10步
    final actualSteps = stepsToUndo.clamp(1, 10);
    
    if (playing.moveHistory.length < actualSteps) return;

    // 将撤销的移动加入撤销栈
    final movesToUndo = playing.moveHistory.sublist(
      playing.moveHistory.length - actualSteps,
    );
    final newUndoStack = [...playing.undoStack, ...movesToUndo];
    
    // 限制撤销栈最多10步
    final trimmedUndoStack = newUndoStack.length > 10
        ? newUndoStack.sublist(newUndoStack.length - 10)
        : newUndoStack;

    // 从初始状态重新执行移动
    var newBoard = BoardState.initial();
    final newMoveHistory = playing.moveHistory.sublist(
      0,
      playing.moveHistory.length - actualSteps,
    );

    for (final move in newMoveHistory) {
      final result = _gameEngine.executeMove(newBoard, move.from, move.to);
      if (result.success && result.newBoard != null) {
        newBoard = result.newBoard!;
      }
    }

    emit(playing.copyWith(
      boardState: newBoard,
      selectedPiece: null,
      clearSelectedPiece: true,
      validMoves: const [],
      moveHistory: newMoveHistory,
      undoStack: trimmedUndoStack,
      lastMove: newMoveHistory.isNotEmpty ? newMoveHistory.last : null,
      clearLastMove: newMoveHistory.isEmpty,
    ),);
  }

  /// 处理重做移动事件
  Future<void> _onRedoMove(RedoMoveEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (!playing.canRedo || playing.isAIThinking) return;

    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);

    // 计算要重做的步数
    final stepsToRedo = event.steps.clamp(1, playing.undoStack.length);
    
    if (playing.undoStack.isEmpty || stepsToRedo <= 0) return;

    // 从撤销栈中取出移动
    final movesToRedo = playing.undoStack.sublist(
      playing.undoStack.length - stepsToRedo,
    );
    final newUndoStack = playing.undoStack.sublist(
      0,
      playing.undoStack.length - stepsToRedo,
    );

    // 重新构建棋盘状态
    var newBoard = BoardState.initial();
    final newMoveHistory = [...playing.moveHistory, ...movesToRedo];

    for (final move in newMoveHistory) {
      final result = _gameEngine.executeMove(newBoard, move.from, move.to);
      if (result.success && result.newBoard != null) {
        newBoard = result.newBoard!;
      }
    }

    emit(playing.copyWith(
      boardState: newBoard,
      selectedPiece: null,
      clearSelectedPiece: true,
      validMoves: const [],
      moveHistory: newMoveHistory,
      undoStack: newUndoStack,
      lastMove: newMoveHistory.last,
    ),);
  }

  /// 处理AI移动事件
  Future<void> _onAIPlay(AIPlayEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (playing.mode != GameMode.pve || playing.currentPlayer != PieceType.white) {
      return;
    }

    // 标记AI正在思考
    emit(playing.copyWith(
      isAIThinking: true,
      aiThinkingProgress: 0.0,
      aiThinkingStatus: '初始化...',
    ),);

    // 创建AI实例
    _audioCoordinator.onGameEvent(audio.GameEvent.aiThinking);

    final aiDifficulty = AIDifficulty.fromString(playing.aiDifficulty ?? 'medium');
    final ai = MinimaxAI(aiDifficulty);
    
    // 设置进度回调
    ai.setProgressCallback((progress, status) {
      if (state is GamePlaying) {
        emit((state as GamePlaying).copyWith(
          isAIThinking: true,
          aiThinkingProgress: progress,
          aiThinkingStatus: status,
        ),);
      }
    });
    
    // AI思考
    final aiMove = await ai.selectMove(playing.boardState);
    
    if (aiMove == null) {
      // AI无法移动，游戏结束
      emit(GameOver(
        boardState: playing.boardState,
        mode: playing.mode,
        gameResult: GameResult.blackWin(
          reason: '白方无子可走',
          moveCount: playing.moveHistory.length,
          duration: Duration.zero,
        ),
        moveHistory: playing.moveHistory,
        lastMove: playing.lastMove,
        aiDifficulty: playing.aiDifficulty,
      ),);
      return;
    }
    
    // 取消AI思考标记
    emit(playing.copyWith(
      isAIThinking: false,
      aiThinkingProgress: 0.0,
      aiThinkingStatus: '',
    ),);

    // 执行AI移动
    add(MovePieceEvent(from: aiMove.from, to: aiMove.to));
  }

  /// 处理保存游戏事件
  Future<void> _onSaveGame(SaveGameEvent event, Emitter<GameState> emit) async {
    if (state is! GamePlaying) return;
    
    final playing = state as GamePlaying;
    
    try {
      final gameSave = GameSave(
        id: 'current_game',
        saveTime: DateTime.now(),
        boardState: BoardStateData.fromBoardState(playing.boardState),
        moveHistory: playing.moveHistory
            .map((m) => MoveData.fromMove(m))
            .toList(),
        currentPlayer: playing.currentPlayer == PieceType.black ? 'black' : 'white',
        mode: playing.mode.toJson(),
        aiDifficulty: playing.aiDifficulty,
      );
      
      final success = await _storageService.saveGame(gameSave);
      if (success) {
        _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
      }
    } catch (e) {
      logger.error('保存游戏失败', 'GameBloc', e);
    }
  }

  /// 处理加载游戏事件
  Future<void> _onLoadGame(LoadGameEvent event, Emitter<GameState> emit) async {
    try {
      final gameSave = await _storageService.loadGame();
      if (gameSave == null) {
        return;
      }
      
      final currentPlayer = gameSave.currentPlayer == 'black' 
          ? PieceType.black 
          : PieceType.white;
      
      final boardState = gameSave.boardState.toBoardState(currentPlayer);
      final moveHistory = gameSave.moveHistory
          .map((m) => m.toMove())
          .toList();
      
      final mode = GameModeExtensions.fromJson(gameSave.mode);
      
      emit(GamePlaying(
        boardState: boardState,
        moveHistory: moveHistory,
        mode: mode,
        aiDifficulty: gameSave.aiDifficulty,
      ),);
      
      _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
      
      // 加载后删除存档
      await _storageService.deleteGameSave();
    } catch (e) {
      logger.error('加载游戏失败', 'GameBloc', e);
    }
  }

  /// 处理设置变更事件
  Future<void> _onSettingsChanged(SettingsChangedEvent event, Emitter<GameState> emit) async {
    // 更新音效设置
    var newSettings = _audioCoordinator.settings;
    var updated = false;

    if (event.soundEnabled != null) {
      newSettings = newSettings.copyWith(soundEnabled: event.soundEnabled);
      updated = true;
    }

    if (event.musicEnabled != null) {
      newSettings = newSettings.copyWith(musicEnabled: event.musicEnabled);
      updated = true;
    }

    if (updated) {
      await _audioCoordinator.updateSettings(newSettings);
    }
    
    // 震动和主题设置已由SettingsPage直接保存到StorageService
    // 这里不需要额外处理
    // 注意：音效/音乐的音量控制和主题切换需要在SettingsPage中直接调用服务
  }

  /// 更新统计数据
  Future<void> _updateStatistics(
    GameResult gameResult,
    int totalMoves,
    GamePlaying playing,
  ) async {
    final isWin = (gameResult.status == GameStatus.blackWin && playing.mode == GameMode.pvp) ||
        (gameResult.status == GameStatus.blackWin && playing.mode == GameMode.pve);
    final isLoss = (gameResult.status == GameStatus.whiteWin && playing.mode == GameMode.pve);
    final isDraw = gameResult.status == GameStatus.draw;

    // 计算吃子数
    final captures = playing.moveHistory.where((m) => m.capturedPiece != null).length;

    await _storageService.updateStatistics(
      isWin: isWin,
      isLoss: isLoss,
      isDraw: isDraw,
      moves: totalMoves,
      captures: captures,
      difficulty: playing.aiDifficulty,
    );
  }

  // Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-11-24
  // Task: 实现语音控制事件处理器（暂时禁用）

  /*
  /// 处理语音控制切换事件
  Future<void> _onVoiceControlToggled(
    VoiceControlToggledEvent event,
    Emitter<GameState> emit,
  ) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (event.enabled) {
      // 初始化语音服务
      final initialized = await _voiceRecognitionService.initialize();
      await _voiceSynthesisService.initialize();

      if (!initialized) {
        logger.error('语音识别初始化失败', 'GameBloc');
        await _voiceSynthesisService.speak('语音识别初始化失败，请检查麦克风权限');
        return;
      }

      // 开始监听语音输入
      await _voiceRecognitionService.startListening(
        onResult: (result) {
          if (result.isFinal && result.confidence > 0.6) {
            add(VoiceCommandReceivedEvent(
              command: result.text,
              confidence: result.confidence,
            ));
          }
        },
        onError: (error) {
          logger.error('语音识别错误', 'GameBloc', error);
        },
      );

      await _voiceSynthesisService.speak('语音控制已开启');
    } else {
      // 停止语音服务
      await _voiceRecognitionService.stopListening();
      await _voiceSynthesisService.speak('语音控制已关闭');
    }

    emit(playing.copyWith(
      isVoiceControlEnabled: event.enabled,
    ));
  }

  /// 处理语音指令事件
  Future<void> _onVoiceCommandReceived(
    VoiceCommandReceivedEvent event,
    Emitter<GameState> emit,
  ) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (!playing.isVoiceControlEnabled) return;
    if (playing.isAITurn || playing.isAIThinking) {
      await _voiceSynthesisService.speak('请等待对方行棋');
      return;
    }

    // 解析语音指令
    final position = VoiceCommandParser.parse(event.command);

    if (position == null) {
      // 解析失败，尝试模糊匹配
      final candidates = VoiceCommandParser.fuzzyMatch(event.command);
      if (candidates.isEmpty) {
        await _voiceSynthesisService.speak('未识别到有效位置，请重新说明');
      } else if (candidates.length == 1) {
        // 只有一个候选，自动使用
        _handleVoicePosition(candidates[0], playing, emit);
      } else {
        // 多个候选，提示用户
        await _voiceSynthesisService.speak('位置不明确，请说出完整坐标');
      }
      return;
    }

    // 更新状态
    emit(playing.copyWith(
      lastVoiceCommand: event.command,
      voiceCommandConfidence: event.confidence,
    ));

    _handleVoicePosition(position, playing, emit);
  }

  /// 处理语音位置输入
  void _handleVoicePosition(
    Position position,
    GamePlaying playing,
    Emitter<GameState> emit,
  ) {
    final piece = playing.boardState.getPiece(position);

    if (playing.selectedPiece == null) {
      // 没有选中棋子，尝试选中
      if (piece == playing.currentPlayer) {
        add(SelectPieceEvent(position));
        _voiceSynthesisService.speak(
          '已选中${VoiceCommandParser.formatPosition(position)}的棋子',
        );
      } else {
        _voiceSynthesisService.speak('该位置没有您的棋子');
      }
    } else {
      // 已有选中棋子，尝试移动
      if (_moveValidator.isValidMove(playing.boardState, playing.selectedPiece!, position)) {
        add(MovePieceEvent(from: playing.selectedPiece!, to: position));
        _voiceSynthesisService.speak(
          '移动到${VoiceCommandParser.formatPosition(position)}',
        );
      } else {
        _voiceSynthesisService.speak('无法移动到该位置');
      }
    }
  }

  /// 处理语音播报请求事件
  Future<void> _onVoiceAnnouncementRequested(
    VoiceAnnouncementRequestedEvent event,
    Emitter<GameState> emit,
  ) async {
    if (state is! GamePlaying) return;
    final playing = state as GamePlaying;

    if (!playing.isVoiceControlEnabled) return;

    // 构建播报文本
    final fromText = VoiceCommandParser.formatPosition(event.from);
    final toText = VoiceCommandParser.formatPosition(event.to);

    String announcement = '对方从$fromText移动到$toText';

    if (event.isCaptureMove) {
      announcement += '，吃掉了你的一个棋子';
    }

    // 添加棋盘状态信息
    final blackCount = playing.boardState.blackPieces.length;
    final whiteCount = playing.boardState.whitePieces.length;
    announcement += '。当前黑方还剩$blackCount个棋子，白方还剩$whiteCount个棋子';

    // 播报
    await _voiceSynthesisService.speak(announcement);
  }
  */
}
