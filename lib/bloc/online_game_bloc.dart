// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: 实现在线对战状态管理BLoC

import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../models/board_state.dart';
import '../models/online_match.dart';
import '../models/websocket_message.dart';
import '../models/message_type.dart';
import '../models/move.dart';
import '../models/position.dart';
import '../models/piece_type.dart';
import '../engine/game_engine.dart';
import '../services/websocket_service.dart';
import '../services/audio_coordinator.dart' as audio;
import '../services/logger_service.dart';
import 'online_game_event.dart';
import 'online_game_state.dart';

/// 在线对战BLoC
/// 
/// 负责管理在线对战的状态和逻辑，包括：
/// - 匹配流程
/// - 游戏进行
/// - WebSocket通信
/// - 断线处理
class OnlineGameBloc extends Bloc<OnlineGameEvent, OnlineGameState> {
  final WebSocketService _webSocketService;
  final GameEngine _gameEngine;
  final audio.AudioCoordinator _audioCoordinator;
  
  StreamSubscription<WebSocketMessage>? _messageSubscription;
  String? _currentPlayerId;

  OnlineGameBloc({
    WebSocketService? webSocketService,
    GameEngine? gameEngine,
    audio.AudioCoordinator? audioCoordinator,
  })  : _webSocketService = webSocketService ?? WebSocketService(),
        _gameEngine = gameEngine ?? GameEngine(),
        _audioCoordinator = audioCoordinator ?? audio.AudioCoordinator(),
        super(const OnlineGameInitial()) {
    _audioCoordinator.initialize();
    // 注册事件处理器
    on<StartMatchingEvent>(_onStartMatching);
    on<CancelMatchingEvent>(_onCancelMatching);
    on<MatchFoundEvent>(_onMatchFound);
    on<LocalPlayerMovedEvent>(_onLocalPlayerMoved);
    on<OpponentMovedEvent>(_onOpponentMoved);
    on<OpponentDisconnectedEvent>(_onOpponentDisconnected);
    on<ReconnectEvent>(_onReconnect);
    on<OnlineGameOverEvent>(_onGameOver);
    on<ExitOnlineGameEvent>(_onExitGame);

    // 监听WebSocket消息
    _listenToMessages();
  }

  /// 监听WebSocket消息
  void _listenToMessages() {
    _messageSubscription = _webSocketService.messageStream.listen(
      (message) {
        _handleWebSocketMessage(message);
      },
      onError: (error) {
        add(const ExitOnlineGameEvent());
      },
    );
  }

  /// 处理WebSocket消息
  void _handleWebSocketMessage(WebSocketMessage message) {
    switch (message.type) {
      case MessageType.matchFound:
        final matchId = message.matchId ?? '';
        final opponentId = message.payload['opponentId'] as String? ?? '';
        final isFirstPlayer = message.payload['isFirstPlayer'] as bool? ?? false;
        add(MatchFoundEvent(
          matchId: matchId,
          opponentId: opponentId,
          isFirstPlayer: isFirstPlayer,
        ),);
        break;

      case MessageType.move:
        final moveData = message.payload['move'] as Map<String, dynamic>?;
        if (moveData != null) {
          final move = _parseMoveFromPayload(moveData);
          if (move != null) {
            add(OpponentMovedEvent(move));
          }
        }
        break;

      case MessageType.disconnect:
        add(const OpponentDisconnectedEvent());
        break;

      case MessageType.gameOver:
        final winnerId = message.payload['winnerId'] as String? ?? '';
        final reason = message.payload['reason'] as String? ?? '游戏结束';
        add(OnlineGameOverEvent(winnerId: winnerId, reason: reason));
        break;

      default:
        break;
    }
  }

  /// 从payload解析Move
  Move? _parseMoveFromPayload(Map<String, dynamic> payload) {
    try {
      final fromData = payload['from'] as Map<String, dynamic>;
      final toData = payload['to'] as Map<String, dynamic>;
      final playerStr = payload['player'] as String;
      
      final from = Position(fromData['x'] as int, fromData['y'] as int);
      final to = Position(toData['x'] as int, toData['y'] as int);
      final player = playerStr == 'black' ? PieceType.black : PieceType.white;
      
      Position? capturedPiece;
      if (payload['capturedPiece'] != null) {
        final capturedData = payload['capturedPiece'] as Map<String, dynamic>;
        capturedPiece = Position(
          capturedData['x'] as int,
          capturedData['y'] as int,
        );
      }

      return Move.now(
        from: from,
        to: to,
        player: player,
        capturedPiece: capturedPiece,
      );
    } catch (e) {
      logger.error('解析移动数据失败', 'OnlineGameBloc', e);
      return null;
    }
  }

  /// 处理开始匹配事件
  /// 
  /// 注意：在线对战功能需要WebSocket服务器支持。
  /// 当前版本暂未连接实际服务器，此功能处于演示状态。
  /// 生产环境部署时需要：
  /// 1. 实现并部署WebSocket服务器
  /// 2. 在环境配置文件中设置WS_URL
  /// 3. 取消下方连接代码的注释
  Future<void> _onStartMatching(
    StartMatchingEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    _currentPlayerId = event.playerId;
    
    // NOTE: 在线对战功能需要服务器支持，当前处于演示状态
    // 部署服务器后取消以下代码注释：
    // final connected = await _webSocketService.connect('ws://your-server.com/game');
    // if (!connected) {
    //   emit(OnlineGameError(
    //     message: '无法连接到服务器',
    //     timestamp: DateTime.now(),
    //   ));
    //   return;
    // }

    emit(Matching(
      playerId: event.playerId,
      startTime: DateTime.now(),
    ),);

    // 发送匹配请求
    await _webSocketService.requestMatch(event.playerId);
    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
  }

  /// 处理取消匹配事件
  Future<void> _onCancelMatching(
    CancelMatchingEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (state is Matching && _currentPlayerId != null) {
      await _webSocketService.cancelMatch(_currentPlayerId!);
      _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
    }
    
    emit(const OnlineGameInitial());
  }

  /// 处理匹配成功事件
  Future<void> _onMatchFound(
    MatchFoundEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (_currentPlayerId == null) return;

    final match = OnlineMatch.create(
      matchId: event.matchId,
      player1Id: event.isFirstPlayer ? _currentPlayerId! : event.opponentId,
      player2Id: event.isFirstPlayer ? event.opponentId : _currentPlayerId!,
      player1Color: PieceType.black, // 先手黑棋
    );

    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);

    emit(MatchFound(
      match: match,
      localPlayerId: _currentPlayerId!,
    ),);

    // 延迟后自动进入游戏状态
    await Future.delayed(const Duration(seconds: 2));
    
    if (state is MatchFound) {
      emit(OnlinePlaying(
        match: match,
        localPlayerId: _currentPlayerId!,
        boardState: match.boardState,
        moveHistory: match.moveHistory,
      ),);
    }
  }

  /// 处理本地玩家移动事件
  Future<void> _onLocalPlayerMoved(
    LocalPlayerMovedEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (state is! OnlinePlaying) return;
    final playing = state as OnlinePlaying;

    if (!playing.isLocalPlayerTurn) {
      logger.warning('不是本地玩家回合', 'OnlineGameBloc');
      return;
    }

    // 执行移动
    final result = _gameEngine.executeMove(
      playing.boardState,
      event.move.from,
      event.move.to,
    );

    if (!result.success || result.newBoard == null) {
      logger.warning('移动无效', 'OnlineGameBloc');
      return;
    }

    // 播放音效
    if (result.captured != null) {
      _audioCoordinator.onGameEvent(
        audio.GameEvent.pieceCaptured,
        data: {'player': result.move!.player.getDisplayName()},
      );
    } else {
      _audioCoordinator.onGameEvent(audio.GameEvent.pieceMoved);
    }

    // 更新本地状态
    final newMoveHistory = [...playing.moveHistory, result.move!];
    final updatedMatch = playing.match.copyWith(
      boardState: result.newBoard!,
      moveHistory: newMoveHistory,
      currentTurn: playing.opponentId,
      lastUpdateAt: DateTime.now(),
    );

    // 发送移动到服务器
    await _webSocketService.sendMove(playing.match.matchId, result.move!);

    // 检查游戏是否结束
    if (result.gameResult != null) {
      emit(OnlineGameOver(
        match: updatedMatch,
        localPlayerId: playing.localPlayerId,
        winnerId: playing.localPlayerId,
        reason: result.gameResult!.reason,
        finalBoardState: result.newBoard!,
        moveHistory: newMoveHistory,
      ),);
      return;
    }

    emit(WaitingOpponent(
      match: updatedMatch,
      localPlayerId: playing.localPlayerId,
      boardState: result.newBoard!,
      moveHistory: newMoveHistory,
    ),);
  }

  /// 处理对手移动事件
  Future<void> _onOpponentMoved(
    OpponentMovedEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (state is! WaitingOpponent && state is! OnlinePlaying) return;
    
    final currentState = state;
    late final OnlineMatch match;
    late final String localPlayerId;
    late final BoardState boardState;
    late final List<Move> moveHistory;

    if (currentState is WaitingOpponent) {
      match = currentState.match;
      localPlayerId = currentState.localPlayerId;
      boardState = currentState.boardState;
      moveHistory = currentState.moveHistory;
    } else if (currentState is OnlinePlaying) {
      match = currentState.match;
      localPlayerId = currentState.localPlayerId;
      boardState = currentState.boardState;
      moveHistory = currentState.moveHistory;
    } else {
      return;
    }

    // 执行对手的移动
    final result = _gameEngine.executeMove(
      boardState,
      event.move.from,
      event.move.to,
    );

    if (!result.success || result.newBoard == null) {
      logger.warning('对手移动无效', 'OnlineGameBloc');
      return;
    }

    // 播放音效
    if (result.captured != null) {
      _audioCoordinator.onGameEvent(
        audio.GameEvent.pieceCaptured,
        data: {'player': result.move!.player.getDisplayName()},
      );
    } else {
      _audioCoordinator.onGameEvent(audio.GameEvent.pieceMoved);
    }

    final newMoveHistory = [...moveHistory, result.move!];
    final updatedMatch = match.copyWith(
      boardState: result.newBoard!,
      moveHistory: newMoveHistory,
      currentTurn: localPlayerId,
      lastUpdateAt: DateTime.now(),
    );

    // 检查游戏是否结束
    if (result.gameResult != null) {
      _audioCoordinator.onGameEvent(audio.GameEvent.gameLost, data: {'player': 'opponent'});
      emit(OnlineGameOver(
        match: updatedMatch,
        localPlayerId: localPlayerId,
        winnerId: match.getOpponentId(localPlayerId)!,
        reason: result.gameResult!.reason,
        finalBoardState: result.newBoard!,
        moveHistory: newMoveHistory,
      ),);
      return;
    }

    emit(OnlinePlaying(
      match: updatedMatch,
      localPlayerId: localPlayerId,
      boardState: result.newBoard!,
      moveHistory: newMoveHistory,
      lastMove: result.move,
    ),);
  }

  /// 处理对手断线事件
  Future<void> _onOpponentDisconnected(
    OpponentDisconnectedEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (state is OnlinePlaying) {
      final playing = state as OnlinePlaying;
      emit(OpponentDisconnected(
        match: playing.match,
        localPlayerId: playing.localPlayerId,
        disconnectedAt: DateTime.now(),
      ),);
    }
  }

  /// 处理重连事件
  /// 
  /// 注意：重连功能需要服务器支持会话恢复。
  /// 实现重连逻辑时需要：
  /// 1. 保存断线前的matchId和playerId
  /// 2. 重新建立WebSocket连接
  /// 3. 从服务器获取最新游戏状态
  /// 4. 恢复本地状态并同步棋盘
  Future<void> _onReconnect(
    ReconnectEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    // NOTE: 重连功能需要服务器端支持，当前处于待实现状态
    // 部署服务器后实现以下逻辑：
    // 1. await _webSocketService.reconnect();
    // 2. final gameState = await _webSocketService.getGameState(matchId);
    // 3. 恢复本地状态并同步UI
    logger.warning('重连功能需要服务器支持，当前未实现', 'OnlineGameBloc');
  }

  /// 处理游戏结束事件
  Future<void> _onGameOver(
    OnlineGameOverEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    if (state is OnlinePlaying) {
      final playing = state as OnlinePlaying;
      
      final isWin = event.winnerId == playing.localPlayerId;
      _audioCoordinator.onGameEvent(isWin ? audio.GameEvent.gameWon : audio.GameEvent.gameLost, data: {'player': isWin ? 'you' : 'opponent'});
      
      emit(OnlineGameOver(
        match: playing.match,
        localPlayerId: playing.localPlayerId,
        winnerId: event.winnerId,
        reason: event.reason,
        finalBoardState: playing.boardState,
        moveHistory: playing.moveHistory,
      ),);
    }
  }

  /// 处理退出游戏事件
  Future<void> _onExitGame(
    ExitOnlineGameEvent event,
    Emitter<OnlineGameState> emit,
  ) async {
    await _webSocketService.disconnect();
    _audioCoordinator.onGameEvent(audio.GameEvent.buttonClicked);
    emit(const OnlineGameInitial());
  }

  @override
  Future<void> close() async {
    await _messageSubscription?.cancel();
    await _webSocketService.disconnect();
    return super.close();
  }
}
