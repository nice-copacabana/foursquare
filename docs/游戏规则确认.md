# 游戏规则确认单

<!-- Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-21
     Task: 游戏规则最终确认文档 -->

## ✅ 已确认规则

### 基本信息
- **确认日期**: 2025-10-21
- **项目**: 四子游戏 (FourSquare)
- **状态**: ✅ 全部确认完成

---

## 1. 棋盘与棋子

### 棋盘
- 4×4网格，16个交叉点
- 横竖各4条直线

### 棋子
- **黑方**: 4枚黑色棋子
- **白方**: 4枚白色棋子
- ⚠️ 不使用红色

---

## 2. 初始布局

### 基本模式（固定布局）
```
黑● ─ 黑● ─ 黑● ─ 黑●  (行0: 位置0,0  0,1  0,2  0,3)
│      │      │      │
│      │      │      │
│      │      │      │
│      │      │      │
│      │      │      │
│      │      │      │
白○ ─ 白○ ─ 白○ ─ 白○  (行3: 位置3,0  3,1  3,2  3,3)
```

- **黑方**: 位置 `(0,0), (0,1), (0,2), (0,3)` - 上方一行
- **白方**: 位置 `(3,0), (3,1), (3,2), (3,3)` - 下方一行

### 残局模式（后期实现）
- 随机布局，用于练习和挑战

---

## 3. 移动规则

### 移动方向
- ✅ **仅四方向**: 上、下、左、右
- ❌ **不支持斜向**移动
- 必须沿棋盘线走

### 移动方式
- 每次移动一格
- 不可跳跃
- 必须移动到相邻的空位

### 图示
```
     ↑
     │
 ←─ ○ ─→
     │
     ↓
```

---

## 4. 吃子规则（核心逻辑）

### 基本定义
**吃子**: 当移动后形成特定棋型时，可以吃掉对方一枚棋子。

### 触发条件（必须全部满足）

#### 条件1: 移动棋子参与判定 ⭐⭐⭐⭐⭐
- ✅ **仅刚移动的棋子**可以作为吃子判定的起点
- ❌ 棋盘上其他棋子，即使形成吃子棋型，也不触发

#### 条件2: 形成「己-己-敌」三子紧邻共线 ⭐⭐⭐⭐⭐
**标准棋型**: `己方 ─ 己方 ─ 敌方`（或纵向）

必须满足：
1. 三个棋子在**同一直线**（横向或纵向）
2. 三个棋子**连续紧邻**（中间无空格、无其他棋子）
3. 顺序必须是：己方-己方-敌方
4. **移动的棋子**必须是两个己方棋子之一

#### 条件3: 一次只吃一枚
- 每次移动最多吃掉**一枚**对方棋子（吃掉最后一个敌方棋子）

---

### 吃子检测算法

#### 检测流程
```
移动完成后：
1. 以移动的棋子为起点
2. 向四个方向（上、下、左、右）延伸检测
3. 检查每个方向是否形成「己-己-敌」模式
4. 如果形成，吃掉敌方棋子
```

#### 四个方向检测

**横向检测（左右）**:
```
情况A: 移动棋子在最左
  ○* ─ ○ ─ ● → 可以吃掉●
  (○*表示刚移动的棋子)

情况B: 移动棋子在中间  
  ○ ─ ○* ─ ● → 可以吃掉●
```

**纵向检测（上下）**:
```
情况A: 移动棋子在最上
  ○*
  │
  ○
  │
  ●  → 可以吃掉●

情况B: 移动棋子在中间
  ○
  │
  ○*
  │
  ●  → 可以吃掉●
```

---

### 正确示例

#### 示例1: 横向吃子（移动到左侧）
```
移动前:
空 ─ ○ ─ ●

移动: 白方棋子从别处移动到最左位置

移动后:
○* ─ ○ ─ ●  (形成己-己-敌)

结果: ✅ 吃掉黑方●，变为 ○ ─ ○ ─ 空
```

#### 示例2: 横向吃子（移动到中间）
```
移动前:
○ ─ 空 ─ ●

移动: 白方棋子从别处移动到中间位置

移动后:
○ ─ ○* ─ ●  (形成己-己-敌)

结果: ✅ 吃掉黑方●，变为 ○ ─ ○ ─ 空
```

#### 示例3: 纵向吃子
```
移动前:          移动后:
○                ○
│                │
空               ○*
│                │
●                ●

结果: ✅ 吃掉黑方●
```

---

### 错误示例（不能吃子）

#### 错误1: 不紧邻（中间有空格）
```
○ ─ 空 ─ ○ ─ ●

❌ 原因: 两个己方棋子不紧邻，不符合「己-己-敌」连续模式
```

#### 错误2: 中间有其他棋子
```
○ ─ ● ─ ○ ─ ●

❌ 原因: 己方棋子之间有敌方棋子阻隔
```

#### 错误3: 顺序错误（己-敌-己）
```
○ ─ ● ─ ○

❌ 原因: 顺序是己-敌-己，不是己-己-敌
注意: 这种棋型在传统规则中可能可以吃子，但本游戏规则不可以！
```

#### 错误4: 被动形成，移动棋子未参与 ⭐关键
```
移动前: ○ ─  ○ ─ ● ─ ●
         A    B   C   D

移动: A位置的○移动到别处

移动后: 空 ─  ○ ─ ● ─ ●
              B   C   D

分析:
虽然看起来形成了 ○(B) - ●(C) - ●(D)
但这不是「己-己-敌」模式，而且移动的是A，不是B或C或D

❌ 原因: 移动的棋子(A)未参与形成的棋型，不触发吃子
```

#### 错误5: 形成多个吃子机会
```
移动后形成:
     ○
     │
○ ─ ○* ─ ●  (横向己-己-敌)
     │
     ●        (纵向己-己-敌)

结果: 只吃掉一个（通常是横向的●，具体可由实现决定）

❌ 原因: 规则规定一次只能吃一个
```

---

### 特殊情况说明

#### Q1: 如果移动后同时形成横向和纵向两个吃子棋型？
**A**: 只吃掉一个。优先级可以设定为：
- 方案A: 横向优先
- 方案B: 纵向优先  
- 方案C: 随机选择

**推荐**: 横向优先（便于编程实现）

#### Q2: 移动的棋子在「己-己-敌」中的位置？
**A**: 移动的棋子必须是两个己方棋子之一，可以在第一个位置或第二个位置。

示例：
```
✅ 正确: ○* ─ ○ ─ ● (移动的是第一个)
✅ 正确: ○ ─ ○* ─ ● (移动的是第二个)
❌ 错误: ○ ─ ○ ─ ●* (移动的是敌方，不可能)
```

#### Q3: 能否连续吃子（一次移动吃多个）？
**A**: 不能。规则明确规定每次移动最多吃一个。

#### Q4: 被吃的棋子会立即移除吗？
**A**: 是的，吃子动作立即生效，棋子从棋盘移除。

---

### 实现伪代码

```python
def detect_capture(board, moved_piece_pos):
    """
    检测是否可以吃子
    
    参数:
        board: 棋盘状态
        moved_piece_pos: 刚移动的棋子位置 (x, y)
    
    返回:
        被吃棋子的位置，如果没有则返回None
    """
    player = board[moved_piece_pos]  # 当前玩家
    enemy = get_enemy(player)         # 对手
    
    # 四个方向: 上、下、左、右
    directions = [(0,-1), (0,1), (-1,0), (1,0)]
    
    for direction in directions:
        # 检查该方向是否形成 己-己-敌
        pos1 = moved_piece_pos
        pos2 = pos1 + direction      # 下一个位置
        pos3 = pos2 + direction      # 再下一个位置
        
        # 检查是否越界
        if not in_bounds(pos2) or not in_bounds(pos3):
            continue
        
        # 检查是否形成 己-己-敌 模式
        if (board[pos1] == player and 
            board[pos2] == player and 
            board[pos3] == enemy):
            return pos3  # 返回被吃棋子位置
    
    # 还需要检查反向（移动的棋子在第二个位置的情况）
    for direction in directions:
        pos0 = moved_piece_pos - direction  # 前一个位置
        pos1 = moved_piece_pos              # 移动的棋子
        pos2 = moved_piece_pos + direction  # 后一个位置
        
        if not in_bounds(pos0) or not in_bounds(pos2):
            continue
        
        # 检查 己-己-敌 (移动的在中间)
        if (board[pos0] == player and 
            board[pos1] == player and 
            board[pos2] == enemy):
            return pos2
    
    return None  # 没有吃子
```

---

### 记忆口诀

**吃子四要素**:
1. **移动参与** - 刚移动的棋子必须参与
2. **己己敌** - 形成己方-己方-敌方顺序
3. **紧邻共线** - 三子连续且在直线上
4. **只吃一个** - 每次最多吃一枚

**快速判断法**:
```
移动后 → 看移动棋子 → 向四周延伸 → 找「己己敌」→ 吃掉敌
```

---

## 5. 先手规则

- ✅ **轮流换先手**
- 第一局：随机决定或黑方先手
- 第二局：白方先手
- 第三局：黑方先手
- 以此类推...

---

## 6. 时间规则

### 每步限时
- **限制**: 1分钟/步
- **超时**: 自动判负

### 总时长
- **限制**: 1小时/局
- **超时**: 自动关闭棋局，按当前棋子数判定胜负

---

## 7. 胜负判定

### 失败条件
1. 己方棋子被吃至仅剩1枚
2. 超时（每步>1分钟）

### 胜利条件
- 对方失败

### 和棋
- ❌ **无和棋**，必分胜负
- 总时长1小时后自动关闭

---

## 8. 悔棋规则

- 单机模式: 暂不实现
- 对战模式: 暂不实现
- **后期可考虑**: 需消耗道具（悔棋卡）

---

## 9. 人机模式

### 两种AI
1. **普通AI**: 规则AI，响应快，适合新手
2. **智能AI**: Minimax算法，策略强，适合进阶玩家

---

## 10. 技术要求

### 团队规模
- **1人 + AI工具全栈开发**

### 技术栈
- **前端**: Flutter (考虑Tauri作为备选)
- **后端**: Node.js + Socket.IO
- **数据库**: MongoDB + Redis

### 文档要求
- ❌ 不要冗余和繁琐
- ✅ 简洁实用为主

---

## 总结

### 核心规则记忆口诀
1. **黑上白下**，四子一排
2. **四方移动**，一次一格
3. **己己敌**紧邻，吃子成功
4. **轮流先手**，公平对局
5. **限时1分钟**，超时判负
6. **剩1子**即败，无和棋

---

**确认人签字**: ________________  
**确认日期**: 2025-10-21
