# 四子游戏 - 实施计划书

<!-- Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-21
     Task: 创建项目实施计划书 -->

## 文档说明
本文档基于《项目立项文档》和《技术架构与开发计划》，提供可直接执行的开发指导。

---

## 第一阶段：需求确认（本周完成）

### 待确认的游戏规则

在开始开发前，请确认以下游戏规则细节：

#### 1. 移动方向 ⭐⭐⭐⭐⭐
**问题**: 棋子可以向哪些方向移动？

**选项A**: 仅四个方向（上、下、左、右）
```
    ↑
  ← ○ →
    ↓
```

**选项B**: 八个方向（包括斜向）
```
  ↖ ↑ ↗
  ← ○ →
  ↙ ↓ ↘
```

**建议**: 选项A（四方向）- 降低游戏复杂度，更易上手

---

#### 2. 初始布局 ⭐⭐⭐⭐⭐
**问题**: 游戏开始时棋子如何摆放？

**选项A**: 固定初始位置
```
示例布局（4x4棋盘）：
● ─ ─ ─ ●     ● = 黑方
│       │
│   ●   ●     ○ = 红方
│       │
○   ○   │
│       │
○ ─ ─ ─ ○
```

**选项B**: 玩家自由摆放（摆放阶段）

**选项C**: 随机生成（保证公平性）

**建议**: 选项A - 更符合传统棋类游戏，便于平衡性调整

**请提供固定初始位置的坐标**: 
- 黑方4子位置: [?, ?], [?, ?], [?, ?], [?, ?]
- 红方4子位置: [?, ?], [?, ?], [?, ?], [?, ?]

---

#### 3. 吃子规则细节 ⭐⭐⭐⭐⭐
**问题A**: 吃子时"相邻"是否也受移动方向限制？
- [ ] 是（与移动方向一致）
- [ ] 否（总是包括斜向）

**问题B**: 一次移动可以吃掉多个对方棋子吗？
```
场景：移动后形成
○ ─ ● ─ ○ ─ ●  ─ ○
```
- [ ] 只吃掉一个（距离最近的）
- [ ] 可以吃掉多个（所有符合条件的）

**问题C**: 吃子必须是移动后立即触发，还是可以主动不吃？
- [ ] 强制吃子（像国际跳棋）
- [ ] 可选吃子

**建议**: 
- 相邻定义与移动方向一致
- 一次移动只能吃掉一个
- 强制吃子（增加策略性）

---

#### 4. 胜负与和棋 ⭐⭐⭐⭐
**问题A**: 和棋/平局规则？

可能的和棋情况：
- [ ] 连续N回合无吃子（建议: 20回合）
- [ ] 重复局面N次（建议: 3次）
- [ ] 双方剩余棋子数相同且无法吃子
- [ ] 不设和棋，必分胜负

**问题B**: 超时判负？（在线/局域网对战）
- [ ] 每步时间限制: __秒
- [ ] 总时间限制: __分钟
- [ ] 无时间限制

**建议**: 
- 采用"连续30回合无吃子"判和
- 在线对战每步限时60秒

---

#### 5. 其他规则 ⭐⭐⭐
**悔棋规则**:
- [ ] 单机模式允许悔棋（无限次）
- [ ] 对战模式不允许悔棋
- [ ] 对战模式允许悔棋（需对方同意，每局限1次）

**先手后手**:
- [ ] 固定红方先手
- [ ] 随机决定
- [ ] 轮流先手（多局对战）

**观战规则**（在线模式）:
- [ ] 允许观战
- [ ] 不允许观战
- [ ] 仅好友可观战

---

### 确认完成后请填写

请在下方填写确认后的规则：

```yaml
游戏规则确认:
  移动方向: [四方向/八方向]
  
  初始布局:
    方案: [固定/自由/随机]
    黑方位置: [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
    红方位置: [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
  
  吃子规则:
    相邻定义: [与移动一致/总是八方向]
    一次吃子数: [一个/多个]
    是否强制吃子: [是/否]
  
  胜负规则:
    和棋条件: [连续N回合无吃子/重复局面/不设和棋]
    和棋回合数: [20/30/其他]
    超时判负: [是/否]
    每步时限: [60秒/其他]
  
  其他规则:
    单机悔棋: [允许/不允许]
    对战悔棋: [不允许/需同意]
    先手规则: [固定红方/随机/轮流]
    观战功能: [允许/不允许/仅好友]
```

---

## 第二阶段：开发环境准备

### 2.1 必要工具安装

#### Flutter环境
```bash
# 1. 下载Flutter SDK
# 访问: https://flutter.dev/docs/get-started/install

# 2. 配置环境变量
# Windows: 将Flutter bin目录添加到PATH

# 3. 验证安装
flutter doctor

# 4. 安装依赖
flutter pub get
```

#### 开发工具
- **推荐IDE**: VS Code + Flutter插件 或 Android Studio
- **Git**: 版本控制
- **Node.js**: 后端开发（阶段4需要）

### 2.2 项目初始化

```bash
# 创建Flutter项目
cd d:\Develop\outworks\foursquare
flutter create foursquare_game

# 进入项目目录
cd foursquare_game

# 运行测试
flutter run
```

### 2.3 目录结构设计

```
foursquare_game/
├── lib/
│   ├── main.dart                 # 应用入口
│   ├── models/                   # 数据模型
│   │   ├── board_state.dart
│   │   ├── position.dart
│   │   ├── move.dart
│   │   └── game_result.dart
│   ├── engine/                   # 游戏引擎
│   │   ├── game_engine.dart      # 规则引擎
│   │   ├── move_validator.dart   # 移动验证
│   │   └── capture_detector.dart # 吃子检测
│   ├── ai/                       # AI模块
│   │   ├── ai_player.dart
│   │   ├── minimax.dart
│   │   └── evaluator.dart
│   ├── network/                  # 网络模块
│   │   ├── local_network.dart    # 局域网
│   │   └── online_network.dart   # 在线对战
│   ├── ui/                       # UI组件
│   │   ├── screens/              # 页面
│   │   ├── widgets/              # 组件
│   │   └── animations/           # 动画
│   ├── state/                    # 状态管理
│   │   └── game_state.dart
│   ├── services/                 # 服务
│   │   ├── audio_service.dart
│   │   └── storage_service.dart
│   └── utils/                    # 工具类
│       └── constants.dart
├── assets/                       # 资源文件
│   ├── images/
│   ├── sounds/
│   └── fonts/
├── test/                         # 测试
│   ├── unit/
│   ├── widget/
│   └── integration/
└── docs/                         # 文档（已创建）
```

---

## 第三阶段：核心开发任务清单

### 阶段1-Week1: 基础架构（第1周）

#### Task 1.1: 数据模型定义
```dart
// models/position.dart
class Position {
  final int x;
  final int y;
  
  Position(this.x, this.y);
  
  // 待实现: 相等性比较、序列化等
}

// models/board_state.dart
enum PieceType { empty, red, black }

class BoardState {
  List<List<PieceType>> grid; // 4x4棋盘
  
  // 待实现: 克隆、吃子、移动等方法
}

// models/move.dart
class Move {
  final Position from;
  final Position to;
  final Position? capturedPiece; // 被吃掉的棋子位置
  
  Move({required this.from, required this.to, this.capturedPiece});
}
```

**验收标准**:
- [ ] 所有模型类编译通过
- [ ] 单元测试覆盖率100%

---

#### Task 1.2: 游戏规则引擎框架
```dart
// engine/game_engine.dart
class GameEngine {
  BoardState boardState;
  
  // 初始化棋盘
  void initializeBoard() {
    // 根据确认的初始布局实现
  }
  
  // 验证移动是否合法
  bool isValidMove(Position from, Position to) {
    // 根据确认的移动方向规则实现
    return false; // TODO
  }
  
  // 执行移动
  Move? executeMove(Position from, Position to) {
    // TODO: 验证、移动、检测吃子
    return null;
  }
  
  // 检测游戏是否结束
  GameResult checkGameOver() {
    // TODO: 检查棋子数量
    return GameResult.ongoing;
  }
}
```

**验收标准**:
- [ ] 框架搭建完成
- [ ] 接口定义清晰
- [ ] 可编译运行（即使方法未实现）

---

#### Task 1.3: 棋盘UI组件
```dart
// ui/widgets/board_widget.dart
class BoardWidget extends StatelessWidget {
  final BoardState boardState;
  final Function(Position) onPositionTap;
  
  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: BoardPainter(boardState),
      child: GestureDetector(
        onTapUp: (details) {
          // 转换点击坐标为棋盘位置
          Position pos = _tapToPosition(details.localPosition);
          onPositionTap(pos);
        },
      ),
    );
  }
}

class BoardPainter extends CustomPainter {
  // TODO: 绘制棋盘网格
  @override
  void paint(Canvas canvas, Size size) {
    // 绘制横线、竖线、棋子
  }
}
```

**验收标准**:
- [ ] 棋盘正确显示4x4网格
- [ ] 棋子正确显示在交叉点
- [ ] 点击能正确识别位置

---

### 阶段1-Week2: 游戏逻辑（第2周）

#### Task 2.1: 移动规则实现
```dart
// engine/move_validator.dart
class MoveValidator {
  // 检查目标位置是否为空
  bool isEmptyPosition(BoardState board, Position pos);
  
  // 检查是否相邻（根据确认的方向规则）
  bool isAdjacent(Position from, Position to);
  
  // 获取所有可移动位置
  List<Position> getValidMoves(BoardState board, Position from);
}
```

**实现要点**:
- 根据确认的移动方向（四方向/八方向）实现
- 边界检查
- 空位检查

**验收标准**:
- [ ] 单元测试100%覆盖
- [ ] 边界情况正确处理

---

#### Task 2.2: 吃子规则实现
```dart
// engine/capture_detector.dart
class CaptureDetector {
  // 检测移动后是否可以吃子
  List<Position> detectCaptures(
    BoardState board, 
    Position movedPiece,
    PieceType player
  ) {
    List<Position> captures = [];
    
    // TODO: 实现吃子检测逻辑
    // 1. 找到己方相邻棋子
    // 2. 检查是否形成"己-敌-己"直线
    // 3. 返回可吃掉的对方棋子位置
    
    return captures;
  }
}
```

**实现要点**:
- 遍历所有方向
- 检测三子共线
- 根据规则确认是吃一个还是多个

**验收标准**:
- [ ] 各种吃子场景测试通过
- [ ] 不应该吃子时不触发

---

#### Task 2.3: 动画实现
```dart
// ui/animations/piece_animation.dart
class PieceMoveAnimation extends StatefulWidget {
  final Position from;
  final Position to;
  final VoidCallback onComplete;
}

// ui/animations/capture_animation.dart
class CaptureAnimation extends StatefulWidget {
  final Position capturedPosition;
  final VoidCallback onComplete;
}
```

**验收标准**:
- [ ] 移动动画流畅（300-500ms）
- [ ] 吃子动画明显（带特效）
- [ ] 动画结束后状态正确更新

---

### 阶段1-Week3: 体验优化（第3周）

#### Task 3.1: 音效集成
```dart
// services/audio_service.dart
class AudioService {
  void playSelectSound();
  void playMoveSound();
  void playCaptureSound();
  void playWinSound();
  void playLoseSound();
  
  void setEnabled(bool enabled);
}
```

**所需音效文件** (放置在 assets/sounds/):
- select.mp3 - 选中音
- move.mp3 - 移动音
- capture.mp3 - 吃子音
- win.mp3 - 胜利音
- lose.mp3 - 失败音

**验收标准**:
- [ ] 所有操作有对应音效
- [ ] 音效可开关
- [ ] 音量适中

---

#### Task 3.2: 主菜单与设置页面
```dart
// ui/screens/main_menu_screen.dart
class MainMenuScreen extends StatelessWidget {
  // 显示:
  // - Logo
  // - 开始游戏（人机对战）
  // - 局域网对战（灰色/未实现）
  // - 在线对战（灰色/未实现）
  // - 游戏规则
  // - 设置
}

// ui/screens/settings_screen.dart
class SettingsScreen extends StatelessWidget {
  // 显示:
  // - 音效开关
  // - 震动开关
  // - AI难度（暂时灰色）
  // - 关于
}
```

**验收标准**:
- [ ] UI美观，符合设计风格
- [ ] 导航流程清晰
- [ ] 设置能持久化保存

---

#### Task 3.3: 规则说明页面
```dart
// ui/screens/rules_screen.dart
class RulesScreen extends StatelessWidget {
  // 使用图文并茂方式说明:
  // 1. 棋盘布局
  // 2. 移动规则
  // 3. 吃子规则（配图示例）
  // 4. 胜负条件
}
```

**验收标准**:
- [ ] 内容准确清晰
- [ ] 配图易于理解
- [ ] 支持滚动查看

---

### 阶段1交付检查清单

完成Week1-3后，应该达到：

**功能层面**:
- [x] 可以开始单机游戏
- [x] 棋子可以正确移动
- [x] 吃子规则正确执行
- [x] 胜负判定正确
- [x] 有完整的UI和音效

**技术层面**:
- [ ] 代码遵循开发规范
- [ ] 单元测试覆盖率>80%
- [ ] 无明显性能问题
- [ ] Git提交历史清晰

**体验层面**:
- [ ] 新用户能快速上手
- [ ] 操作流畅不卡顿
- [ ] UI美观符合主题

---

## 第四阶段：质量检查

### 代码审查要点
- [ ] 是否遵循Dart代码规范
- [ ] 是否有充分的注释
- [ ] 是否有单元测试
- [ ] 是否有性能问题

### 测试用例模板
```dart
// test/unit/engine/move_validator_test.dart
void main() {
  group('MoveValidator Tests', () {
    test('相邻位置判断 - 四方向', () {
      // Given
      Position from = Position(1, 1);
      Position up = Position(0, 1);
      Position diagonal = Position(0, 0);
      
      // When & Then
      expect(MoveValidator.isAdjacent(from, up), true);
      expect(MoveValidator.isAdjacent(from, diagonal), false);
    });
    
    // 更多测试用例...
  });
}
```

---

## 附录：开发规范

### 命名约定
- 类名: PascalCase (GameEngine)
- 变量/方法: camelCase (isValidMove)
- 常量: UPPER_CASE (MAX_BOARD_SIZE)
- 私有成员: _leadingUnderscore (_boardState)

### Git提交规范
```
<type>(<scope>): <subject>

[类型]
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式
refactor: 重构
test: 测试
chore: 构建/工具

[示例]
feat(engine): 实现移动规则验证
fix(ui): 修复棋盘点击偏移问题
docs(readme): 更新安装说明
```

### 代码注释规范
```dart
/// 验证移动是否合法
/// 
/// 根据游戏规则检查从[from]位置到[to]位置的移动是否允许。
/// 
/// 参数:
///   - from: 起始位置
///   - to: 目标位置
/// 
/// 返回:
///   - true: 移动合法
///   - false: 移动非法
/// 
/// 示例:
/// ```dart
/// bool valid = validator.isValidMove(Position(0,0), Position(0,1));
/// ```
bool isValidMove(Position from, Position to) {
  // 实现...
}
```

---

## 下一步行动

### 立即执行（今天）
1. [ ] 与用户确认第一阶段的所有待定规则
2. [ ] 填写"游戏规则确认"表单
3. [ ] 安装Flutter开发环境

### 本周内完成
1. [ ] 创建Flutter项目
2. [ ] 搭建目录结构
3. [ ] 开始Task 1.1: 数据模型定义

### 沟通机制
- 遇到技术问题: 及时记录并寻求帮助
- 规则疑问: 不要假设，务必确认
- 进度汇报: 建议每周五进行进度回顾

---

**祝开发顺利！** 🎮

有任何问题请随时沟通。
