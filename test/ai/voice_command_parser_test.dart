// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-11-24
// Task: 为VoiceCommandParser创建完整单元测试，覆盖所有语音指令解析场景

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/ai/voice_command_parser.dart';
import 'package:foursquare/models/position.dart';

void main() {
  group('VoiceCommandParser - 传统坐标格式解析', () {
    test('应该解析"横1竖2"格式', () {
      final result = VoiceCommandParser.parse('横1竖2');
      expect(result, equals(const Position(1, 2)));
    });

    test('应该解析"横一竖二"中文数字格式', () {
      final result = VoiceCommandParser.parse('横一竖二');
      expect(result, equals(const Position(1, 2)));
    });

    test('应该解析"横三竖四"格式', () {
      final result = VoiceCommandParser.parse('横三竖四');
      expect(result, equals(const Position(3, 4)));
    });

    test('应该解析"行2列3"格式', () {
      final result = VoiceCommandParser.parse('行2列3');
      expect(result, equals(const Position(2, 3)));
    });

    test('应该解析带空格的"横 1 竖 2"', () {
      final result = VoiceCommandParser.parse('横 1 竖 2');
      expect(result, equals(const Position(1, 2)));
    });

    test('应该解析带标点的"横1，竖2"', () {
      final result = VoiceCommandParser.parse('横1，竖2');
      expect(result, equals(const Position(1, 2)));
    });
  });

  group('VoiceCommandParser - 国际坐标格式解析', () {
    test('应该解析"A1"格式', () {
      final result = VoiceCommandParser.parse('A1');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该解析"B2"格式', () {
      final result = VoiceCommandParser.parse('B2');
      expect(result, equals(const Position(1, 1)));
    });

    test('应该解析"C3"格式', () {
      final result = VoiceCommandParser.parse('C3');
      expect(result, equals(const Position(2, 2)));
    });

    test('应该解析"D4"格式', () {
      final result = VoiceCommandParser.parse('D4');
      expect(result, equals(const Position(3, 3)));
    });

    test('应该解析小写"a1"格式', () {
      final result = VoiceCommandParser.parse('a1');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该解析小写"d4"格式', () {
      final result = VoiceCommandParser.parse('d4');
      expect(result, equals(const Position(3, 3)));
    });
  });

  group('VoiceCommandParser - 方向式解析', () {
    test('应该解析"左上"', () {
      final result = VoiceCommandParser.parse('左上');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该解析"右上"', () {
      final result = VoiceCommandParser.parse('右上');
      expect(result, equals(const Position(3, 0)));
    });

    test('应该解析"左下"', () {
      final result = VoiceCommandParser.parse('左下');
      expect(result, equals(const Position(0, 3)));
    });

    test('应该解析"右下"', () {
      final result = VoiceCommandParser.parse('右下');
      expect(result, equals(const Position(3, 3)));
    });

    test('应该解析"中间"', () {
      final result = VoiceCommandParser.parse('中间');
      expect(result, equals(const Position(1, 1)));
    });

    test('应该解析"中心"', () {
      final result = VoiceCommandParser.parse('中心');
      expect(result, equals(const Position(1, 1)));
    });

    test('应该解析"正中"', () {
      final result = VoiceCommandParser.parse('正中');
      expect(result, equals(const Position(2, 2)));
    });
  });

  group('VoiceCommandParser - 自然语言解析', () {
    test('应该解析"移动到横2竖3"', () {
      final result = VoiceCommandParser.parse('移动到横2竖3');
      expect(result, equals(const Position(2, 3)));
    });

    test('应该解析"移到A1"', () {
      final result = VoiceCommandParser.parse('移到A1');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该解析"走到横一竖二"', () {
      final result = VoiceCommandParser.parse('走到横一竖二');
      expect(result, equals(const Position(1, 2)));
    });

    test('应该解析"放在B2"', () {
      final result = VoiceCommandParser.parse('放在B2');
      expect(result, equals(const Position(1, 1)));
    });

    test('应该解析"下在横三竖四"', () {
      final result = VoiceCommandParser.parse('下在横三竖四');
      expect(result, equals(const Position(3, 4)));
    });
  });

  group('VoiceCommandParser - 边界情况处理', () {
    test('空字符串应该返回null', () {
      final result = VoiceCommandParser.parse('');
      expect(result, isNull);
    });

    test('无效坐标"横5竖6"应该返回null', () {
      final result = VoiceCommandParser.parse('横5竖6');
      expect(result, isNull);
    });

    test('无效格式"XYZ"应该返回null', () {
      final result = VoiceCommandParser.parse('XYZ');
      expect(result, isNull);
    });

    test('只有数字"123"应该返回null', () {
      final result = VoiceCommandParser.parse('123');
      expect(result, isNull);
    });

    test('无意义文本"你好世界"应该返回null', () {
      final result = VoiceCommandParser.parse('你好世界');
      expect(result, isNull);
    });
  });

  group('VoiceCommandParser - 模糊匹配', () {
    test('应该返回包含数字1和2的候选位置', () {
      final candidates = VoiceCommandParser.fuzzyMatch('横1竖2');
      expect(candidates, isNotEmpty);
      expect(candidates, contains(const Position(1, 2)));
    });

    test('模糊匹配应该返回多个候选', () {
      final candidates = VoiceCommandParser.fuzzyMatch('一二');
      expect(candidates.length, greaterThan(0));
    });

    test('无匹配内容应该返回空列表', () {
      final candidates = VoiceCommandParser.fuzzyMatch('无效内容');
      expect(candidates, isEmpty);
    });
  });

  group('VoiceCommandParser - 位置格式化', () {
    test('应该格式化Position为中文坐标', () {
      final formatted = VoiceCommandParser.formatPosition(const Position(1, 2));
      expect(formatted, equals('横一竖二'));
    });

    test('应该格式化Position(0,0)为中文坐标', () {
      final formatted = VoiceCommandParser.formatPosition(const Position(0, 0));
      // 注意：0可能映射为"零"或"〇"
      expect(formatted, anyOf(equals('横零竖零'), equals('横〇竖〇')));
    });

    test('应该格式化Position为国际坐标', () {
      final formatted = VoiceCommandParser.formatPositionInternational(
        const Position(1, 2),
      );
      expect(formatted, equals('B3'));
    });

    test('应该格式化Position(0,0)为国际坐标', () {
      final formatted = VoiceCommandParser.formatPositionInternational(
        const Position(0, 0),
      );
      expect(formatted, equals('A1'));
    });

    test('应该格式化Position(3,3)为国际坐标', () {
      final formatted = VoiceCommandParser.formatPositionInternational(
        const Position(3, 3),
      );
      expect(formatted, equals('D4'));
    });
  });

  group('VoiceCommandParser - 复杂场景', () {
    test('应该处理大小写混合的"a1"', () {
      final result = VoiceCommandParser.parse('A1');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该处理包含多余文字的指令', () {
      final result = VoiceCommandParser.parse('我想移动到横2竖3这个位置');
      expect(result, equals(const Position(2, 3)));
    });

    test('应该处理方向+坐标混合', () {
      // 方向优先级更高
      final result = VoiceCommandParser.parse('左上横1竖2');
      expect(result, equals(const Position(0, 0)));
    });

    test('应该处理带噪音的"横，，1，，竖，，2"', () {
      final result = VoiceCommandParser.parse('横，，1，，竖，，2');
      expect(result, equals(const Position(1, 2)));
    });
  });

  group('VoiceCommandParser - 性能测试', () {
    test('解析1000次应该在合理时间内完成', () {
      final stopwatch = Stopwatch()..start();

      for (int i = 0; i < 1000; i++) {
        VoiceCommandParser.parse('横1竖2');
      }

      stopwatch.stop();
      expect(stopwatch.elapsedMilliseconds, lessThan(1000));
    });

    test('模糊匹配1000次应该在合理时间内完成', () {
      final stopwatch = Stopwatch()..start();

      for (int i = 0; i < 1000; i++) {
        VoiceCommandParser.fuzzyMatch('横1竖2');
      }

      stopwatch.stop();
      expect(stopwatch.elapsedMilliseconds, lessThan(2000));
    });
  });
}
