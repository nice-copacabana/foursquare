// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: Position模型单元测试，覆盖所有方法和边界情况

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/models/position.dart';

void main() {
  group('Position', () {
    group('构造函数和属性', () {
      test('应该正确创建Position对象', () {
        const pos = Position(2, 3);
        expect(pos.x, 2);
        expect(pos.y, 3);
      });
    });

    group('isValid', () {
      test('有效位置应返回true', () {
        expect(const Position(0, 0).isValid(), true);
        expect(const Position(3, 3).isValid(), true);
        expect(const Position(1, 2).isValid(), true);
      });

      test('x坐标越界应返回false', () {
        expect(const Position(-1, 0).isValid(), false);
        expect(const Position(4, 0).isValid(), false);
        expect(const Position(5, 2).isValid(), false);
      });

      test('y坐标越界应返回false', () {
        expect(const Position(0, -1).isValid(), false);
        expect(const Position(0, 4).isValid(), false);
        expect(const Position(2, 5).isValid(), false);
      });

      test('x和y都越界应返回false', () {
        expect(const Position(-1, -1).isValid(), false);
        expect(const Position(4, 4).isValid(), false);
      });
    });

    group('getAdjacentPositions', () {
      test('中心位置应返回4个相邻位置', () {
        const pos = Position(1, 1);
        final adjacent = pos.getAdjacentPositions();
        
        expect(adjacent.length, 4);
        expect(adjacent, containsAll([
          const Position(1, 0), // 上
          const Position(1, 2), // 下
          const Position(0, 1), // 左
          const Position(2, 1), // 右
        ]));
      });

      test('左上角位置应返回2个相邻位置', () {
        const pos = Position(0, 0);
        final adjacent = pos.getAdjacentPositions();
        
        expect(adjacent.length, 2);
        expect(adjacent, containsAll([
          const Position(0, 1), // 下
          const Position(1, 0), // 右
        ]));
      });

      test('右下角位置应返回2个相邻位置', () {
        const pos = Position(3, 3);
        final adjacent = pos.getAdjacentPositions();
        
        expect(adjacent.length, 2);
        expect(adjacent, containsAll([
          const Position(3, 2), // 上
          const Position(2, 3), // 左
        ]));
      });

      test('左边缘位置应返回3个相邻位置', () {
        const pos = Position(0, 2);
        final adjacent = pos.getAdjacentPositions();
        
        expect(adjacent.length, 3);
        expect(adjacent, containsAll([
          const Position(0, 1), // 上
          const Position(0, 3), // 下
          const Position(1, 2), // 右
        ]));
      });

      test('上边缘位置应返回3个相邻位置', () {
        const pos = Position(2, 0);
        final adjacent = pos.getAdjacentPositions();
        
        expect(adjacent.length, 3);
        expect(adjacent, containsAll([
          const Position(2, 1), // 下
          const Position(1, 0), // 左
          const Position(3, 0), // 右
        ]));
      });
    });

    group('distanceTo', () {
      test('相同位置距离应为0', () {
        const pos1 = Position(1, 1);
        const pos2 = Position(1, 1);
        expect(pos1.distanceTo(pos2), 0);
      });

      test('相邻位置距离应为1', () {
        const pos1 = Position(1, 1);
        expect(pos1.distanceTo(const Position(1, 0)), 1); // 上
        expect(pos1.distanceTo(const Position(1, 2)), 1); // 下
        expect(pos1.distanceTo(const Position(0, 1)), 1); // 左
        expect(pos1.distanceTo(const Position(2, 1)), 1); // 右
      });

      test('对角线不相邻，距离应为2', () {
        const pos1 = Position(1, 1);
        expect(pos1.distanceTo(const Position(0, 0)), 2);
        expect(pos1.distanceTo(const Position(2, 2)), 2);
      });

      test('最远距离应为6（对角）', () {
        const pos1 = Position(0, 0);
        const pos2 = Position(3, 3);
        expect(pos1.distanceTo(pos2), 6);
      });
    });

    group('copyWith', () {
      test('不传参数应返回相同位置', () {
        const pos = Position(1, 2);
        final copy = pos.copyWith();
        expect(copy, pos);
      });

      test('只修改x应返回新的x坐标', () {
        const pos = Position(1, 2);
        final copy = pos.copyWith(x: 3);
        expect(copy.x, 3);
        expect(copy.y, 2);
      });

      test('只修改y应返回新的y坐标', () {
        const pos = Position(1, 2);
        final copy = pos.copyWith(y: 3);
        expect(copy.x, 1);
        expect(copy.y, 3);
      });

      test('同时修改x和y', () {
        const pos = Position(1, 2);
        final copy = pos.copyWith(x: 3, y: 0);
        expect(copy.x, 3);
        expect(copy.y, 0);
      });
    });

    group('equals和hashCode', () {
      test('相同坐标的Position应相等', () {
        const pos1 = Position(1, 2);
        const pos2 = Position(1, 2);
        expect(pos1, pos2);
        expect(pos1.hashCode, pos2.hashCode);
      });

      test('不同坐标的Position应不相等', () {
        const pos1 = Position(1, 2);
        const pos2 = Position(1, 3);
        const pos3 = Position(2, 2);
        expect(pos1, isNot(pos2));
        expect(pos1, isNot(pos3));
      });
    });

    group('toString', () {
      test('应返回正确的字符串格式', () {
        const pos = Position(1, 2);
        expect(pos.toString(), 'Position(1, 2)');
      });
    });
  });
}
