// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: BoardState模型单元测试，覆盖所有方法和边界情况

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/models/board_state.dart';
import 'package:foursquare/models/position.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('BoardState', () {
    group('初始化', () {
      test('initial工厂方法应创建正确的初始棋盘', () {
        final board = BoardState.initial();

        // 检查黑方初始位置
        expect(board.getPiece(const Position(0, 0)), PieceType.black);
        expect(board.getPiece(const Position(1, 0)), PieceType.black);
        expect(board.getPiece(const Position(2, 0)), PieceType.black);
        expect(board.getPiece(const Position(3, 0)), PieceType.black);

        // 检查白方初始位置
        expect(board.getPiece(const Position(0, 3)), PieceType.white);
        expect(board.getPiece(const Position(1, 3)), PieceType.white);
        expect(board.getPiece(const Position(2, 3)), PieceType.white);
        expect(board.getPiece(const Position(3, 3)), PieceType.white);

        // 检查中间空位
        expect(board.getPiece(const Position(0, 1)), PieceType.empty);
        expect(board.getPiece(const Position(2, 2)), PieceType.empty);

        // 检查当前玩家
        expect(board.currentPlayer, PieceType.black);

        // 检查棋子数量
        expect(board.blackPieces.length, 4);
        expect(board.whitePieces.length, 4);
      });
    });

    group('getPiece', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('应返回正确的棋子类型', () {
        expect(board.getPiece(const Position(0, 0)), PieceType.black);
        expect(board.getPiece(const Position(0, 3)), PieceType.white);
        expect(board.getPiece(const Position(1, 1)), PieceType.empty);
      });

      test('越界位置应返回empty', () {
        expect(board.getPiece(const Position(-1, 0)), PieceType.empty);
        expect(board.getPiece(const Position(4, 0)), PieceType.empty);
        expect(board.getPiece(const Position(0, 4)), PieceType.empty);
      });
    });

    group('setPiece', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('应正确设置棋子', () {
        final newBoard = board.setPiece(const Position(1, 1), PieceType.black);
        expect(newBoard.getPiece(const Position(1, 1)), PieceType.black);
        expect(newBoard.blackPieces.length, 5);
      });

      test('应更新棋子列表', () {
        final newBoard = board.setPiece(const Position(1, 1), PieceType.white);
        expect(newBoard.whitePieces.contains(const Position(1, 1)), true);
        expect(newBoard.whitePieces.length, 5);
      });

      test('替换对手棋子应更新两方列表', () {
        var newBoard = board.setPiece(const Position(0, 0), PieceType.white);
        expect(newBoard.blackPieces.contains(const Position(0, 0)), false);
        expect(newBoard.whitePieces.contains(const Position(0, 0)), true);
        expect(newBoard.blackPieces.length, 3);
        expect(newBoard.whitePieces.length, 5);
      });

      test('设置为empty应从列表中移除', () {
        final newBoard = board.setPiece(const Position(0, 0), PieceType.empty);
        expect(newBoard.blackPieces.contains(const Position(0, 0)), false);
        expect(newBoard.blackPieces.length, 3);
      });

      test('越界位置应返回原棋盘', () {
        final newBoard = board.setPiece(const Position(4, 0), PieceType.black);
        expect(newBoard, board);
      });

      test('不应修改原棋盘', () {
        final originalPieceCount = board.blackPieces.length;
        board.setPiece(const Position(1, 1), PieceType.black);
        expect(board.blackPieces.length, originalPieceCount);
      });
    });

    group('isEmpty', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('空位应返回true', () {
        expect(board.isEmpty(const Position(1, 1)), true);
        expect(board.isEmpty(const Position(2, 2)), true);
      });

      test('有棋子的位置应返回false', () {
        expect(board.isEmpty(const Position(0, 0)), false);
        expect(board.isEmpty(const Position(0, 3)), false);
      });
    });

    group('movePiece', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('应正确移动棋子', () {
        final newBoard = board.movePiece(
          const Position(0, 0),
          const Position(0, 1),
        );
        expect(newBoard.getPiece(const Position(0, 0)), PieceType.empty);
        expect(newBoard.getPiece(const Position(0, 1)), PieceType.black);
      });

      test('移动应更新棋子列表', () {
        final newBoard = board.movePiece(
          const Position(0, 0),
          const Position(0, 1),
        );
        expect(newBoard.blackPieces.contains(const Position(0, 0)), false);
        expect(newBoard.blackPieces.contains(const Position(0, 1)), true);
        expect(newBoard.blackPieces.length, 4);
      });

      test('移动空位应返回原棋盘', () {
        final newBoard = board.movePiece(
          const Position(1, 1),
          const Position(1, 2),
        );
        expect(newBoard, board);
      });

      test('越界位置应返回原棋盘', () {
        final newBoard = board.movePiece(
          const Position(0, 0),
          const Position(4, 0),
        );
        expect(newBoard, board);
      });
    });

    group('removePiece', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('应移除棋子', () {
        final newBoard = board.removePiece(const Position(0, 0));
        expect(newBoard.getPiece(const Position(0, 0)), PieceType.empty);
        expect(newBoard.blackPieces.length, 3);
      });
    });

    group('getPieceCount', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('初始黑方棋子数应为4', () {
        expect(board.getPieceCount(PieceType.black), 4);
      });

      test('初始白方棋子数应为4', () {
        expect(board.getPieceCount(PieceType.white), 4);
      });

      test('初始空位数应为8', () {
        expect(board.getPieceCount(PieceType.empty), 8);
      });

      test('移除棋子后数量应减少', () {
        final newBoard = board.removePiece(const Position(0, 0));
        expect(newBoard.getPieceCount(PieceType.black), 3);
        expect(newBoard.getPieceCount(PieceType.empty), 9);
      });
    });

    group('getAllPieces', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('应返回所有黑方棋子位置', () {
        final pieces = board.getAllPieces(PieceType.black);
        expect(pieces.length, 4);
        expect(pieces, containsAll([
          const Position(0, 0),
          const Position(1, 0),
          const Position(2, 0),
          const Position(3, 0),
        ]),);
      });

      test('应返回所有白方棋子位置', () {
        final pieces = board.getAllPieces(PieceType.white);
        expect(pieces.length, 4);
        expect(pieces, containsAll([
          const Position(0, 3),
          const Position(1, 3),
          const Position(2, 3),
          const Position(3, 3),
        ]),);
      });

      test('应返回所有空位', () {
        final pieces = board.getAllPieces(PieceType.empty);
        expect(pieces.length, 8);
      });
    });

    group('switchPlayer', () {
      test('应切换当前玩家', () {
        final board = BoardState.initial();
        expect(board.currentPlayer, PieceType.black);

        final newBoard = board.switchPlayer();
        expect(newBoard.currentPlayer, PieceType.white);

        final backBoard = newBoard.switchPlayer();
        expect(backBoard.currentPlayer, PieceType.black);
      });
    });

    group('copyWith', () {
      late BoardState board;

      setUp(() {
        board = BoardState.initial();
      });

      test('无参数应创建完全相同的副本', () {
        final copy = board.copyWith();
        expect(copy, board);
      });

      test('应允许修改currentPlayer', () {
        final copy = board.copyWith(currentPlayer: PieceType.white);
        expect(copy.currentPlayer, PieceType.white);
        expect(board.currentPlayer, PieceType.black);
      });

      test('修改副本不应影响原对象', () {
        final copy = board.copyWith();
        final modified = copy.setPiece(const Position(1, 1), PieceType.black);
        expect(board.isEmpty(const Position(1, 1)), true);
        expect(modified.isEmpty(const Position(1, 1)), false);
      });
    });

    group('toDebugString', () {
      test('应生成可读的调试字符串', () {
        final board = BoardState.initial();
        final debugStr = board.toDebugString();
        
        expect(debugStr.contains('●'), true);
        expect(debugStr.contains('○'), true);
        expect(debugStr.contains('·'), true);
        expect(debugStr.contains('当前玩家'), true);
        expect(debugStr.contains('黑方棋子数: 4'), true);
        expect(debugStr.contains('白方棋子数: 4'), true);
      });
    });

    group('equals和hashCode', () {
      test('相同状态的棋盘应相等', () {
        final board1 = BoardState.initial();
        final board2 = BoardState.initial();
        expect(board1, board2);
        expect(board1.hashCode, board2.hashCode);
      });

      test('不同状态的棋盘应不相等', () {
        final board1 = BoardState.initial();
        final board2 = board1.movePiece(
          const Position(0, 0),
          const Position(0, 1),
        );
        expect(board1, isNot(board2));
      });
    });
  });
}
