// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: Move模型单元测试

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/models/move.dart';
import 'package:foursquare/models/position.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('Move', () {
    group('构造和属性', () {
      test('应正确创建Move对象', () {
        final timestamp = DateTime.now();
        final move = Move(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
          timestamp: timestamp,
        );

        expect(move.from, const Position(0, 0));
        expect(move.to, const Position(0, 1));
        expect(move.player, PieceType.black);
        expect(move.capturedPiece, null);
        expect(move.timestamp, timestamp);
      });

      test('应支持吃子记录', () {
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
          capturedPiece: const Position(0, 2),
        );

        expect(move.capturedPiece, const Position(0, 2));
        expect(move.hasCapture, true);
      });
    });

    group('factory now', () {
      test('应使用当前时间创建Move', () {
        final before = DateTime.now();
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.white,
        );
        final after = DateTime.now();

        expect(
          move.timestamp.isAfter(before.subtract(const Duration(seconds: 1))),
          true,
        );
        expect(
          move.timestamp.isBefore(after.add(const Duration(seconds: 1))),
          true,
        );
      });
    });

    group('hasCapture', () {
      test('有吃子应返回true', () {
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
          capturedPiece: const Position(0, 2),
        );
        expect(move.hasCapture, true);
      });

      test('无吃子应返回false', () {
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );
        expect(move.hasCapture, false);
      });
    });

    group('序列化和反序列化', () {
      test('toJson应返回正确的Map', () {
        final timestamp = DateTime(2025, 10, 22, 10, 30);
        final move = Move(
          from: const Position(1, 2),
          to: const Position(1, 3),
          player: PieceType.white,
          capturedPiece: const Position(1, 4),
          timestamp: timestamp,
        );

        final json = move.toJson();
        expect(json['from'], {'x': 1, 'y': 2});
        expect(json['to'], {'x': 1, 'y': 3});
        expect(json['player'], 'white');
        expect(json['capturedPiece'], {'x': 1, 'y': 4});
        expect(json['timestamp'], timestamp.toIso8601String());
      });

      test('toJson对无吃子的移动应正确处理', () {
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );

        final json = move.toJson();
        expect(json['capturedPiece'], null);
      });

      test('fromJson应正确反序列化', () {
        final timestamp = DateTime(2025, 10, 22, 10, 30);
        final json = {
          'from': {'x': 2, 'y': 1},
          'to': {'x': 2, 'y': 2},
          'player': 'black',
          'capturedPiece': {'x': 2, 'y': 3},
          'timestamp': timestamp.toIso8601String(),
        };

        final move = Move.fromJson(json);
        expect(move.from, const Position(2, 1));
        expect(move.to, const Position(2, 2));
        expect(move.player, PieceType.black);
        expect(move.capturedPiece, const Position(2, 3));
        expect(move.timestamp, timestamp);
      });

      test('序列化和反序列化应保持一致', () {
        final original = Move(
          from: const Position(0, 0),
          to: const Position(1, 1),
          player: PieceType.white,
          capturedPiece: const Position(2, 2),
          timestamp: DateTime(2025, 10, 22),
        );

        final json = original.toJson();
        final restored = Move.fromJson(json);

        expect(restored, original);
      });
    });

    group('getDescription', () {
      test('无吃子移动的描述', () {
        final move = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );

        final desc = move.getDescription();
        expect(desc, contains('黑方'));
        expect(desc, contains('(0,0)'));
        expect(desc, contains('(0,1)'));
        expect(desc.contains('吃'), false);
      });

      test('有吃子移动的描述', () {
        final move = Move.now(
          from: const Position(1, 1),
          to: const Position(1, 2),
          player: PieceType.white,
          capturedPiece: const Position(1, 3),
        );

        final desc = move.getDescription();
        expect(desc, contains('白方'));
        expect(desc, contains('(1,1)'));
        expect(desc, contains('(1,2)'));
        expect(desc, contains('吃掉'));
        expect(desc, contains('(1,3)'));
      });
    });

    group('copyWith', () {
      test('无参数应返回相同的Move', () {
        final original = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );

        final copy = original.copyWith();
        expect(copy, original);
      });

      test('应允许修改单个属性', () {
        final original = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );

        final copy = original.copyWith(
          player: PieceType.white,
        );

        expect(copy.player, PieceType.white);
        expect(copy.from, original.from);
        expect(copy.to, original.to);
      });
    });

    group('equals和hashCode', () {
      test('相同属性的Move应相等', () {
        final timestamp = DateTime(2025, 10, 22);
        final move1 = Move(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
          timestamp: timestamp,
        );
        final move2 = Move(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
          timestamp: timestamp,
        );

        expect(move1, move2);
        expect(move1.hashCode, move2.hashCode);
      });

      test('不同属性的Move应不相等', () {
        final move1 = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 1),
          player: PieceType.black,
        );
        final move2 = Move.now(
          from: const Position(0, 0),
          to: const Position(0, 2),
          player: PieceType.black,
        );

        expect(move1, isNot(move2));
      });
    });
  });
}
