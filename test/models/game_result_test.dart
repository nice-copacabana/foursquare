// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: GameResult模型单元测试

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/models/game_result.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('GameStatus', () {
    group('isGameOver', () {
      test('ongoing应返回false', () {
        expect(GameStatus.ongoing.isGameOver, false);
      });

      test('结束状态应返回true', () {
        expect(GameStatus.blackWin.isGameOver, true);
        expect(GameStatus.whiteWin.isGameOver, true);
        expect(GameStatus.timeout.isGameOver, true);
        expect(GameStatus.abandoned.isGameOver, true);
      });
    });

    group('getDisplayText', () {
      test('应返回正确的显示文本', () {
        expect(GameStatus.ongoing.getDisplayText(), '进行中');
        expect(GameStatus.blackWin.getDisplayText(), '黑方胜利');
        expect(GameStatus.whiteWin.getDisplayText(), '白方胜利');
        expect(GameStatus.timeout.getDisplayText(), '超时');
        expect(GameStatus.abandoned.getDisplayText(), '弃局');
      });
    });
  });

  group('GameResult', () {
    group('工厂方法', () {
      test('blackWin应创建黑方胜利结果', () {
        final result = GameResult.blackWin(
          reason: '白方棋子不足',
          moveCount: 20,
          duration: const Duration(minutes: 5),
        );

        expect(result.status, GameStatus.blackWin);
        expect(result.winner, PieceType.black);
        expect(result.reason, '白方棋子不足');
        expect(result.moveCount, 20);
        expect(result.duration, const Duration(minutes: 5));
      });

      test('whiteWin应创建白方胜利结果', () {
        final result = GameResult.whiteWin(
          reason: '黑方棋子不足',
          moveCount: 25,
          duration: const Duration(minutes: 8),
        );

        expect(result.status, GameStatus.whiteWin);
        expect(result.winner, PieceType.white);
        expect(result.reason, '黑方棋子不足');
      });

      test('timeout应创建超时结果', () {
        final result = GameResult.timeout(
          timeoutPlayer: PieceType.black,
          moveCount: 15,
          duration: const Duration(minutes: 10),
        );

        expect(result.status, GameStatus.timeout);
        expect(result.winner, PieceType.white); // 对手获胜
        expect(result.reason, contains('黑方'));
        expect(result.reason, contains('超时'));
      });

      test('abandoned应创建弃局结果', () {
        final result = GameResult.abandoned(
          abandonedPlayer: PieceType.white,
          moveCount: 10,
          duration: const Duration(minutes: 3),
        );

        expect(result.status, GameStatus.abandoned);
        expect(result.winner, PieceType.black); // 对手获胜
        expect(result.reason, contains('白方'));
        expect(result.reason, contains('认输'));
      });
    });

    group('isGameOver', () {
      test('应反映游戏状态', () {
        const ongoing = GameResult(
          status: GameStatus.ongoing,
          reason: '',
          moveCount: 0,
          duration: Duration.zero,
        );
        expect(ongoing.isGameOver, false);

        final finished = GameResult.blackWin(
          reason: 'test',
          moveCount: 1,
          duration: Duration.zero,
        );
        expect(finished.isGameOver, true);
      });
    });

    group('getSummary', () {
      test('应生成包含所有信息的摘要', () {
        final result = GameResult.blackWin(
          reason: '白方棋子不足',
          moveCount: 30,
          duration: const Duration(hours: 1, minutes: 23, seconds: 45),
        );

        final summary = result.getSummary();
        expect(summary, contains('黑方胜利'));
        expect(summary, contains('获胜方: 黑方'));
        expect(summary, contains('原因: 白方棋子不足'));
        expect(summary, contains('总步数: 30'));
        expect(summary, contains('1小时23分45秒'));
      });

      test('应正确格式化不同时长', () {
        final result1 = GameResult.blackWin(
          reason: 'test',
          moveCount: 1,
          duration: const Duration(seconds: 45),
        );
        expect(result1.getSummary(), contains('45秒'));

        final result2 = GameResult.blackWin(
          reason: 'test',
          moveCount: 1,
          duration: const Duration(minutes: 5, seconds: 30),
        );
        expect(result2.getSummary(), contains('5分30秒'));

        final result3 = GameResult.blackWin(
          reason: 'test',
          moveCount: 1,
          duration: const Duration(hours: 2, minutes: 15),
        );
        expect(result3.getSummary(), contains('2小时15分'));
      });
    });

    group('序列化和反序列化', () {
      test('toJson应返回正确的Map', () {
        final result = GameResult.whiteWin(
          reason: '黑方棋子不足',
          moveCount: 40,
          duration: const Duration(minutes: 10, seconds: 30),
        );

        final json = result.toJson();
        expect(json['status'], 'whiteWin');
        expect(json['winner'], 'white');
        expect(json['reason'], '黑方棋子不足');
        expect(json['moveCount'], 40);
        expect(json['duration'], 630000); // 10.5分钟 = 630000毫秒
      });

      test('fromJson应正确反序列化', () {
        final json = {
          'status': 'blackWin',
          'winner': 'black',
          'reason': '白方棋子不足',
          'moveCount': 25,
          'duration': 300000, // 5分钟
        };

        final result = GameResult.fromJson(json);
        expect(result.status, GameStatus.blackWin);
        expect(result.winner, PieceType.black);
        expect(result.reason, '白方棋子不足');
        expect(result.moveCount, 25);
        expect(result.duration, const Duration(minutes: 5));
      });

      test('序列化和反序列化应保持一致', () {
        final original = GameResult.timeout(
          timeoutPlayer: PieceType.white,
          moveCount: 18,
          duration: const Duration(minutes: 15),
        );

        final json = original.toJson();
        final restored = GameResult.fromJson(json);

        expect(restored, original);
      });

      test('应正确处理null winner', () {
        const result = GameResult(
          status: GameStatus.ongoing,
          winner: null,
          reason: '游戏进行中',
          moveCount: 5,
          duration: Duration(minutes: 2),
        );

        final json = result.toJson();
        expect(json['winner'], null);

        final restored = GameResult.fromJson(json);
        expect(restored.winner, null);
      });
    });

    group('equals和hashCode', () {
      test('相同属性的结果应相等', () {
        final result1 = GameResult.blackWin(
          reason: 'test',
          moveCount: 20,
          duration: const Duration(minutes: 5),
        );
        final result2 = GameResult.blackWin(
          reason: 'test',
          moveCount: 20,
          duration: const Duration(minutes: 5),
        );

        expect(result1, result2);
        expect(result1.hashCode, result2.hashCode);
      });

      test('不同属性的结果应不相等', () {
        final result1 = GameResult.blackWin(
          reason: 'test',
          moveCount: 20,
          duration: const Duration(minutes: 5),
        );
        final result2 = GameResult.whiteWin(
          reason: 'test',
          moveCount: 20,
          duration: const Duration(minutes: 5),
        );

        expect(result1, isNot(result2));
      });
    });
  });
}
