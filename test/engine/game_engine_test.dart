// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: GameEngine集成测试，验证完整游戏流程

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/engine/game_engine.dart';
import 'package:foursquare/models/board_state.dart';
import 'package:foursquare/models/position.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('GameEngine', () {
    late GameEngine engine;
    late BoardState board;

    setUp(() {
      engine = GameEngine();
      board = BoardState.initial();
      engine.startNewGame();
    });

    group('executeMove', () {
      test('合法移动应成功', () {
        final result = engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );

        expect(result.success, true);
        expect(result.move, isNotNull);
        expect(result.newBoard, isNotNull);
        expect(result.error, isNull);
      });

      test('非法移动应失败', () {
        final result = engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 2), // 距离2，非法
        );

        expect(result.success, false);
        expect(result.error, isNotNull);
        expect(result.newBoard, isNull);
      });

      test('移动后应切换玩家', () {
        final result = engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );

        expect(result.newBoard!.currentPlayer, PieceType.white);
      });

      test('移动应记录到历史', () {
        engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );

        expect(engine.moveHistory.length, 1);
        expect(engine.moveHistory.first.from, const Position(0, 0));
        expect(engine.moveHistory.first.to, const Position(0, 1));
      });
    });

    group('executeMove - 吃子', () {
      test('形成吃子应移除被吃棋子', () {
        // 设置吃子场景: ○ 空 ○ ●
        var testBoard = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final result = engine.executeMove(
          testBoard,
          const Position(0, 2),
          const Position(1, 2),
        );

        expect(result.success, true);
        expect(result.captured, const Position(3, 2));
        expect(
          result.newBoard!.getPiece(const Position(3, 2)),
          PieceType.empty,
        );
      });

      test('吃子应记录在Move中', () {
        var testBoard = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final result = engine.executeMove(
          testBoard,
          const Position(0, 2),
          const Position(1, 2),
        );

        expect(result.move!.hasCapture, true);
        expect(result.move!.capturedPiece, const Position(3, 2));
      });
    });

    group('checkGameOver', () {
      test('初始棋盘游戏未结束', () {
        final result = engine.checkGameOver(board);
        expect(result, isNull);
      });

      test('黑方棋子<=1应判定白方获胜', () {
        var testBoard = board;
        // 移除大部分黑方棋子
        for (var i = 0; i < 3; i++) {
          testBoard = testBoard.removePiece(Position(i, 0));
        }

        final result = engine.checkGameOver(testBoard);
        expect(result, isNotNull);
        expect(result!.winner, PieceType.white);
      });

      test('白方棋子<=1应判定黑方获胜', () {
        var testBoard = board;
        // 移除大部分白方棋子
        for (var i = 0; i < 3; i++) {
          testBoard = testBoard.removePiece(Position(i, 3));
        }

        final result = engine.checkGameOver(testBoard);
        expect(result, isNotNull);
        expect(result!.winner, PieceType.black);
      });

      test('游戏结束时应包含统计信息', () {
        var testBoard = board;
        for (var i = 0; i < 3; i++) {
          testBoard = testBoard.removePiece(Position(i, 0));
        }

        final result = engine.checkGameOver(testBoard);
        expect(result!.moveCount, isNotNull);
        expect(result.duration, isNotNull);
      });
    });

    group('getPossibleMoves', () {
      test('初始棋盘黑方应有可能的移动', () {
        final moves = engine.getPossibleMoves(board, PieceType.black);
        expect(moves.isNotEmpty, true);
        expect(moves.length, 4); // 4个黑方棋子
      });

      test('初始棋盘白方应有可能的移动', () {
        final moves = engine.getPossibleMoves(board, PieceType.white);
        expect(moves.isNotEmpty, true);
        expect(moves.length, 4); // 4个白方棋子
      });
    });

    group('simulateMove', () {
      test('应返回模拟后的棋盘', () {
        final newBoard = engine.simulateMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );

        expect(newBoard, isNotNull);
        expect(newBoard!.getPiece(const Position(0, 0)), PieceType.empty);
        expect(newBoard.getPiece(const Position(0, 1)), PieceType.black);
      });

      test('模拟移动不应影响原棋盘', () {
        final originalBlackCount = board.getPieceCount(PieceType.black);
        
        engine.simulateMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );

        expect(board.getPieceCount(PieceType.black), originalBlackCount);
        expect(board.getPiece(const Position(0, 0)), PieceType.black);
      });

      test('非法移动应返回null', () {
        final newBoard = engine.simulateMove(
          board,
          const Position(0, 0),
          const Position(0, 2),
        );

        expect(newBoard, isNull);
      });

      test('模拟移动应处理吃子', () {
        var testBoard = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final newBoard = engine.simulateMove(
          testBoard,
          const Position(0, 2),
          const Position(1, 2),
        );

        expect(newBoard, isNotNull);
        expect(newBoard!.getPiece(const Position(3, 2)), PieceType.empty);
      });
    });

    group('evaluateBoard', () {
      test('棋子数量相同应评分为0', () {
        final score = engine.evaluateBoard(board, PieceType.black);
        expect(score, 0);
      });

      test('己方棋子多应得正分', () {
        var testBoard = board.removePiece(const Position(0, 3));
        final score = engine.evaluateBoard(testBoard, PieceType.black);
        expect(score, greaterThan(0));
      });

      test('对方棋子多应得负分', () {
        var testBoard = board.removePiece(const Position(0, 0));
        final score = engine.evaluateBoard(testBoard, PieceType.black);
        expect(score, lessThan(0));
      });
    });

    group('undoLastMove', () {
      test('无历史记录应返回null', () {
        final result = engine.undoLastMove(board);
        expect(result, isNull);
      });

      test('应撤销上一步移动', () {
        var currentBoard = board;
        final result = engine.executeMove(
          currentBoard,
          const Position(0, 0),
          const Position(0, 1),
        );
        currentBoard = result.newBoard!;

        final undoBoard = engine.undoLastMove(currentBoard);
        expect(undoBoard, isNotNull);
        // 撤销后应回到初始状态
        expect(undoBoard!.getPiece(const Position(0, 0)), PieceType.black);
        expect(undoBoard.getPiece(const Position(0, 1)), PieceType.empty);
      });

      test('撤销应减少历史记录', () {
        var currentBoard = board;
        engine.executeMove(
          currentBoard,
          const Position(0, 0),
          const Position(0, 1),
        );
        
        expect(engine.moveHistory.length, 1);
        
        engine.undoLastMove(currentBoard);
        expect(engine.moveHistory.length, 0);
      });
    });

    group('完整游戏流程', () {
      test('应能完成一个简单游戏', () {
        var currentBoard = board;

        // 黑方移动
        var result = engine.executeMove(
          currentBoard,
          const Position(0, 0),
          const Position(0, 1),
        );
        expect(result.success, true);
        currentBoard = result.newBoard!;

        // 白方移动
        result = engine.executeMove(
          currentBoard,
          const Position(0, 3),
          const Position(0, 2),
        );
        expect(result.success, true);
        currentBoard = result.newBoard!;

        // 游戏应继续
        expect(result.gameOver, false);
        expect(engine.moveHistory.length, 2);
      });

      test('吃子导致胜利', () {
        // 设置一个快速胜利的场景
        var testBoard = BoardState.initial();
        // 只留黑方2个棋子，白方4个棋子
        testBoard = testBoard
            .removePiece(const Position(1, 0))
            .removePiece(const Position(2, 0));

        // 设置吃子场景
        testBoard = testBoard
            .setPiece(const Position(0, 1), PieceType.white)
            .setPiece(const Position(1, 1), PieceType.white)
            .setPiece(const Position(2, 1), PieceType.black)
            .switchPlayer();

        // 白方移动吃掉黑方棋子
        final result = engine.executeMove(
          testBoard,
          const Position(0, 1),
          const Position(0, 2),
        );

        var currentBoard = result.newBoard!;
        
        // 再设置吃子吃掉最后一个黑方棋子
        currentBoard = currentBoard
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final finalResult = engine.executeMove(
          currentBoard,
          const Position(1, 2),
          const Position(1, 3),
        );

        // 检查是否结束（黑方只剩1个棋子）
        final gameResult = engine.checkGameOver(finalResult.newBoard!);
        if (gameResult != null) {
          expect(gameResult.winner, PieceType.white);
        }
      });
    });

    group('getCaptureOpportunities', () {
      test('应返回所有吃子机会', () {
        var testBoard = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final opportunities = engine.getCaptureOpportunities(
          testBoard,
          PieceType.white,
        );

        expect(opportunities.isNotEmpty, true);
      });
    });

    group('reset', () {
      test('应清空历史记录', () {
        engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );
        
        engine.reset();
        expect(engine.moveHistory, isEmpty);
      });
    });

    group('性能测试', () {
      test('executeMove应在10ms内完成', () {
        final stopwatch = Stopwatch()..start();
        
        engine.executeMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );
        
        stopwatch.stop();
        expect(stopwatch.elapsedMilliseconds, lessThan(10));
      });
    });
  });
}
