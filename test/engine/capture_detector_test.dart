// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: CaptureDetector单元测试，覆盖所有吃子场景和边界情况

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/engine/capture_detector.dart';
import 'package:foursquare/models/board_state.dart';
import 'package:foursquare/models/position.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('CaptureDetector', () {
    late CaptureDetector detector;

    setUp(() {
      detector = CaptureDetector();
    });

    group('detectCapture - 横向吃子', () {
      test('横向：移动棋子在第一个位置（左到右：移动-己-敌）', () {
        // 布局: ○ 空 ○ ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer(); // 切换到白方

        // 白方移动到(1,2)，形成 ○ ○ ●
        board = board.movePiece(const Position(0, 2), const Position(1, 2));

        final captured = detector.detectCapture(
          board,
          const Position(1, 2),
          PieceType.white,
        );

        expect(captured, const Position(3, 2));
      });

      test('横向：移动棋子在第二个位置（左到右：己-移动-敌）', () {
        // 布局: ○ 空 ○ ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        // 白方从(2,2)移动到(1,2)不会吃子（需要重新布局）
        // 正确布局: ○ 空 ○ ●
        board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.black)
            .switchPlayer();

        board = board.setPiece(const Position(1, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(1, 2),
          PieceType.white,
        );

        expect(captured, const Position(2, 2));
      });

      test('横向：从右到左吃子', () {
        // 布局: ● ○ 空 ○
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.black)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.white)
            .switchPlayer();

        board = board.setPiece(const Position(2, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 2),
          PieceType.white,
        );

        expect(captured, const Position(0, 2));
      });
    });

    group('detectCapture - 纵向吃子', () {
      test('纵向：移动棋子在第一个位置（上到下：移动-己-敌）', () {
        // 布局（从上到下）: 空 ○ ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.black)
            .switchPlayer();

        board = board.setPiece(const Position(2, 0), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 0),
          PieceType.white,
        );

        expect(captured, const Position(2, 2));
      });

      test('纵向：移动棋子在第二个位置（上到下：己-移动-敌）', () {
        // 布局: ○ 空 ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 0), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.black)
            .switchPlayer();

        board = board.setPiece(const Position(2, 1), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 1),
          PieceType.white,
        );

        expect(captured, const Position(2, 2));
      });

      test('纵向：从下到上吃子', () {
        // 布局（从上到下）: ● ○ 空 ○
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 0), PieceType.black)
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 3), PieceType.white)
            .switchPlayer();

        board = board.setPiece(const Position(2, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 2),
          PieceType.white,
        );

        expect(captured, const Position(2, 0));
      });
    });

    group('detectCapture - 边界情况', () {
      test('不形成吃子应返回null', () {
        // 布局: ○ ○ 空 (没有敌方棋子)
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(1, 2), PieceType.white)
            .switchPlayer();

        final captured = detector.detectCapture(
          board,
          const Position(1, 2),
          PieceType.white,
        );

        expect(captured, null);
      });

      test('棋子不连续应返回null', () {
        // 布局: ○ 空 ○ ●（中间有空位）
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        final captured = detector.detectCapture(
          board,
          const Position(0, 2),
          PieceType.white,
        );

        expect(captured, null);
      });

      test('顺序错误应返回null（敌-己-己）', () {
        // 布局: ● ○ ○
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.black)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .switchPlayer();

        final captured = detector.detectCapture(
          board,
          const Position(2, 2),
          PieceType.white,
        );

        expect(captured, null);
      });

      test('移动棋子未参与三子连线应返回null', () {
        // 棋盘上有○ ○ ●，但移动的棋子在其他位置
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.black)
            .setPiece(const Position(3, 3), PieceType.white)
            .switchPlayer();

        // 移动的是(3,3)的棋子，它不参与(0,2)-(1,2)-(2,2)的连线
        final captured = detector.detectCapture(
          board,
          const Position(3, 3),
          PieceType.white,
        );

        expect(captured, null);
      });

      test('越界情况应返回null', () {
        var board = BoardState.initial();
        
        final captured = detector.detectCapture(
          board,
          const Position(4, 4),
          PieceType.white,
        );

        expect(captured, null);
      });

      test('empty类型应返回null', () {
        var board = BoardState.initial();

        final captured = detector.detectCapture(
          board,
          const Position(1, 1),
          PieceType.empty,
        );

        expect(captured, null);
      });
    });

    group('detectCapture - 四个方向', () {
      test('向上吃子', () {
        // 布局（列2）: ● ○ 空 ○
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 0), PieceType.black)
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 3), PieceType.white)
            .switchPlayer();

        board = board.setPiece(const Position(2, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 2),
          PieceType.white,
        );

        expect(captured, const Position(2, 0));
      });

      test('向下吃子', () {
        // 布局（列2）: ○ 空 ○ ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 0), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(2, 3), PieceType.black)
            .switchPlayer();

        board = board.setPiece(const Position(2, 1), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 1),
          PieceType.white,
        );

        expect(captured, const Position(2, 3));
      });

      test('向左吃子', () {
        // 布局（行2）: ● ○ 空 ○
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.black)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.white)
            .switchPlayer();

        board = board.setPiece(const Position(2, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(2, 2),
          PieceType.white,
        );

        expect(captured, const Position(0, 2));
      });

      test('向右吃子', () {
        // 布局（行2）: ○ 空 ○ ●
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 2), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.black)
            .switchPlayer();

        board = board.setPiece(const Position(1, 2), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(1, 2),
          PieceType.white,
        );

        expect(captured, const Position(3, 2));
      });
    });

    group('detectCapture - 实际游戏场景', () {
      test('初始棋盘第一步移动不应吃子', () {
        var board = BoardState.initial();
        board = board.movePiece(const Position(0, 0), const Position(0, 1));

        final captured = detector.detectCapture(
          board,
          const Position(0, 1),
          PieceType.black,
        );

        expect(captured, null);
      });

      test('黑方吃白方棋子', () {
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(1, 1), PieceType.black)
            .setPiece(const Position(1, 2), PieceType.black)
            .setPiece(const Position(1, 3), PieceType.white);

        final captured = detector.detectCapture(
          board,
          const Position(1, 2),
          PieceType.black,
        );

        expect(captured, const Position(1, 3));
      });

      test('白方吃黑方棋子', () {
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(2, 0), PieceType.white)
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 2), PieceType.black)
            .switchPlayer();

        final captured = detector.detectCapture(
          board,
          const Position(2, 1),
          PieceType.white,
        );

        expect(captured, const Position(2, 2));
      });
    });

    group('getAllCaptureOpportunities', () {
      test('初始棋盘应没有吃子机会', () {
        final board = BoardState.initial();
        final opportunities = detector.getAllCaptureOpportunities(
          board,
          PieceType.black,
        );

        expect(opportunities, isEmpty);
      });

      test('应找到所有可以吃子的移动', () {
        // 设置一个有吃子机会的棋盘
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(0, 1), PieceType.black)
            .setPiece(const Position(1, 1), PieceType.black)
            .setPiece(const Position(2, 1), PieceType.white);

        final opportunities = detector.getAllCaptureOpportunities(
          board,
          PieceType.black,
        );

        expect(opportunities.isNotEmpty, true);
      });
    });

    group('getCaptureRisks', () {
      test('被包围的棋子应有风险', () {
        var board = BoardState.initial();
        board = board
            .setPiece(const Position(1, 1), PieceType.black)
            .setPiece(const Position(0, 1), PieceType.white)
            .setPiece(const Position(2, 1), PieceType.white);

        final risks = detector.getCaptureRisks(
          board,
          const Position(1, 1),
        );

        // 应该检测到风险
        expect(risks.isNotEmpty, true);
      });

      test('空位应返回空列表', () {
        final board = BoardState.initial();
        final risks = detector.getCaptureRisks(
          board,
          const Position(1, 1),
        );

        expect(risks, isEmpty);
      });
    });
  });
}
