// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-22
// Task: MoveValidator单元测试，覆盖所有验证场景

import 'package:flutter_test/flutter_test.dart';
import 'package:foursquare/engine/move_validator.dart';
import 'package:foursquare/models/board_state.dart';
import 'package:foursquare/models/position.dart';
import 'package:foursquare/models/piece_type.dart';

void main() {
  group('MoveValidator', () {
    late MoveValidator validator;
    late BoardState board;

    setUp(() {
      validator = MoveValidator();
      board = BoardState.initial();
    });

    group('isValidMove', () {
      test('有效移动应返回true', () {
        // 黑方棋子从(0,0)移至(0,1)
        final result = validator.isValidMove(
          board,
          const Position(0, 0),
          const Position(0, 1),
        );
        expect(result, true);
      });

      test('移动到有棋子的位置应返回false', () {
        // 尝试移动到另一个黑方棋子位置
        final result = validator.isValidMove(
          board,
          const Position(0, 0),
          const Position(1, 0),
        );
        expect(result, false);
      });

      test('移动非当前玩家的棋子应返回false', () {
        // 黑方回合尝试移动白方棋子
        final result = validator.isValidMove(
          board,
          const Position(0, 3),
          const Position(0, 2),
        );
        expect(result, false);
      });

      test('移动空位应返回false', () {
        final result = validator.isValidMove(
          board,
          const Position(1, 1),
          const Position(1, 2),
        );
        expect(result, false);
      });

      test('移动到非相邻位置应返回false', () {
        // 尝试移动两格
        final result = validator.isValidMove(
          board,
          const Position(0, 0),
          const Position(0, 2),
        );
        expect(result, false);
      });

      test('对角线移动应返回false', () {
        final result = validator.isValidMove(
          board,
          const Position(0, 0),
          const Position(1, 1),
        );
        expect(result, false);
      });

      test('越界起始位置应返回false', () {
        final result = validator.isValidMove(
          board,
          const Position(-1, 0),
          const Position(0, 0),
        );
        expect(result, false);
      });

      test('越界目标位置应返回false', () {
        final result = validator.isValidMove(
          board,
          const Position(0, 0),
          const Position(0, -1),
        );
        expect(result, false);
      });

      test('白方回合应验证白方棋子', () {
        final whiteBoard = board.switchPlayer();
        final result = validator.isValidMove(
          whiteBoard,
          const Position(0, 3),
          const Position(0, 2),
        );
        expect(result, true);
      });

      test('四个方向的移动都应有效', () {
        // 创建一个中间有棋子的棋盘
        final customBoard = board
            .setPiece(const Position(2, 2), PieceType.black)
            .switchPlayer()
            .switchPlayer(); // 保持黑方回合

        // 上
        expect(
          validator.isValidMove(
            customBoard,
            const Position(2, 2),
            const Position(2, 1),
          ),
          true,
        );

        // 下
        expect(
          validator.isValidMove(
            customBoard,
            const Position(2, 2),
            const Position(2, 3),
          ),
          false, // 有白方棋子
        );

        // 左
        expect(
          validator.isValidMove(
            customBoard,
            const Position(2, 2),
            const Position(1, 2),
          ),
          true,
        );

        // 右
        expect(
          validator.isValidMove(
            customBoard,
            const Position(2, 2),
            const Position(3, 2),
          ),
          true,
        );
      });
    });

    group('getValidMoves', () {
      test('应返回所有合法移动位置', () {
        final moves = validator.getValidMoves(
          board,
          const Position(0, 0),
        );

        expect(moves.length, 1); // 只有下
        expect(moves, containsAll([
          const Position(0, 1),
        ]));
      });

      test('角落棋子应有1个可移动位置', () {
        final moves = validator.getValidMoves(
          board,
          const Position(3, 0),
        );

        expect(moves.length, 1); // 只有下
        expect(moves, containsAll([
          const Position(3, 1),
        ]));
      });

      test('中间棋子应有多个可移动位置', () {
        final customBoard = board
            .setPiece(const Position(2, 2), PieceType.black);

        final moves = validator.getValidMoves(
          customBoard,
          const Position(2, 2),
        );

        expect(moves.length, 3); // 上左右，下面有白棋
      });

      test('被包围的棋子应返回空列表', () {
        // 创建一个被完全包围的棋子
        var customBoard = BoardState.initial();
        customBoard = customBoard
            .setPiece(const Position(2, 2), PieceType.black)
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 3), PieceType.white)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.white);

        final moves = validator.getValidMoves(
          customBoard,
          const Position(2, 2),
        );

        expect(moves, isEmpty);
      });

      test('非当前玩家的棋子应返回空列表', () {
        final moves = validator.getValidMoves(
          board,
          const Position(0, 3), // 白方棋子，但当前是黑方回合
        );

        expect(moves, isEmpty);
      });

      test('空位应返回空列表', () {
        final moves = validator.getValidMoves(
          board,
          const Position(1, 1),
        );

        expect(moves, isEmpty);
      });

      test('越界位置应返回空列表', () {
        final moves = validator.getValidMoves(
          board,
          const Position(4, 4),
        );

        expect(moves, isEmpty);
      });
    });

    group('isAdjacent', () {
      test('上方相邻应返回true', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(1, 0),
          ),
          true,
        );
      });

      test('下方相邻应返回true', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(1, 2),
          ),
          true,
        );
      });

      test('左侧相邻应返回true', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(0, 1),
          ),
          true,
        );
      });

      test('右侧相邻应返回true', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(2, 1),
          ),
          true,
        );
      });

      test('对角线不相邻应返回false', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(0, 0),
          ),
          false,
        );
      });

      test('距离2应返回false', () {
        expect(
          validator.isAdjacent(
            const Position(0, 0),
            const Position(0, 2),
          ),
          false,
        );
      });

      test('相同位置应返回false', () {
        expect(
          validator.isAdjacent(
            const Position(1, 1),
            const Position(1, 1),
          ),
          false,
        );
      });
    });

    group('getAllPossibleMoves', () {
      test('应返回黑方所有可能移动', () {
        final moves = validator.getAllPossibleMoves(
          board,
          PieceType.black,
        );

        expect(moves.length, 4); // 4个黑方棋子
        expect(moves.keys, containsAll([
          const Position(0, 0),
          const Position(1, 0),
          const Position(2, 0),
          const Position(3, 0),
        ]));
      });

      test('应返回白方所有可能移动', () {
        final whiteBoard = board.switchPlayer();
        final moves = validator.getAllPossibleMoves(
          whiteBoard,
          PieceType.white,
        );

        expect(moves.length, 4); // 4个白方棋子
      });

      test('被吃掉的棋子不应包含在结果中', () {
        final customBoard = board
            .removePiece(const Position(0, 0))
            .removePiece(const Position(1, 0));

        final moves = validator.getAllPossibleMoves(
          customBoard,
          PieceType.black,
        );

        expect(moves.length, 2); // 只剩2个黑方棋子
      });

      test('完全被包围的棋子不应在结果中', () {
        var customBoard = BoardState.initial();
        customBoard = customBoard
            .setPiece(const Position(2, 2), PieceType.black)
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(2, 3), PieceType.white)
            .setPiece(const Position(1, 2), PieceType.white)
            .setPiece(const Position(3, 2), PieceType.white);

        final moves = validator.getAllPossibleMoves(
          customBoard,
          PieceType.black,
        );

        // 被包围的棋子不在结果中
        expect(moves.containsKey(const Position(2, 2)), false);
      });
    });

    group('hasValidMoves', () {
      test('初始棋盘黑方应有合法移动', () {
        final result = validator.hasValidMoves(board, PieceType.black);
        expect(result, true);
      });

      test('初始棋盘白方应有合法移动', () {
        final result = validator.hasValidMoves(board, PieceType.white);
        expect(result, true);
      });

      test('所有棋子被包围应返回false', () {
        // 创建一个所有棋子都被包围的极端情况
        // 这在实际游戏中几乎不会发生，但需要测试边界情况
        var customBoard = BoardState(
          grid: List.generate(4, (y) => List.filled(4, PieceType.white)),
          blackPieces: const [],
          whitePieces: [
            const Position(0, 0),
            const Position(1, 0),
            const Position(2, 0),
            const Position(3, 0),
            const Position(0, 1),
            const Position(1, 1),
            const Position(2, 1),
            const Position(3, 1),
            const Position(0, 2),
            const Position(1, 2),
            const Position(2, 2),
            const Position(3, 2),
            const Position(0, 3),
            const Position(1, 3),
            const Position(2, 3),
            const Position(3, 3),
          ],
          currentPlayer: PieceType.white,
        );

        final result = validator.hasValidMoves(customBoard, PieceType.white);
        expect(result, false);
      });

      test('只剩一个棋子且周围都有棋子应返回false', () {
        var customBoard = BoardState.initial();
        // 移除大部分黑方棋子，只留一个被包围的
        customBoard = customBoard
            .removePiece(const Position(0, 0))
            .removePiece(const Position(1, 0))
            .removePiece(const Position(3, 0))
            .setPiece(const Position(2, 1), PieceType.white)
            .setPiece(const Position(1, 0), PieceType.white)
            .setPiece(const Position(3, 0), PieceType.white);

        final result = validator.hasValidMoves(customBoard, PieceType.black);
        expect(result, false);
      });
    });
  });
}
